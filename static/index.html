<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Aero Transcript Analyzer</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
:root {
  --bg:       #050b16;
  --surface:  #122338;
  --card:     #0f1d33;
  --border:   #2f4f73;
  --accent:   #4fd6ff;
  --accent2:  #7cf8d6;
  --gold:     #9ce7ff;
  --green:    #57ffd5;
  --text:     #e7f7ff;
  --muted:    #8faec3;
  --radius:   12px;
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; }
body {
  font-family: 'Segoe UI', system-ui, sans-serif;
  background:
    radial-gradient(1200px 800px at 8% -10%, rgba(79,214,255,.22), transparent 55%),
    radial-gradient(900px 640px at 92% -8%, rgba(124,248,214,.16), transparent 52%),
    radial-gradient(1100px 760px at 50% 115%, rgba(120,170,255,.18), transparent 60%),
    linear-gradient(165deg, #050b16 0%, #081628 45%, #050d1d 100%);
  color: var(--text);
  min-height: 100vh;
}

/* ‚îÄ‚îÄ Layout ‚îÄ‚îÄ */
.app { display: flex; flex-direction: column; min-height: 100vh; }

header {
  background: linear-gradient(180deg, rgba(24,49,78,.72), rgba(11,27,47,.78));
  border-bottom: 1px solid var(--border);
  box-shadow: 0 12px 28px rgba(0,0,0,.25), inset 0 1px 0 rgba(170,235,255,.12);
  backdrop-filter: blur(8px);
  padding: 16px 24px;
  display: flex;
  align-items: center;
  gap: 20px;
  flex-wrap: wrap;
}
.logo { font-size: 1.3rem; font-weight: 700; color: var(--accent); white-space: nowrap; text-shadow: 0 0 14px rgba(79,214,255,.45); }
.logo span { color: var(--text); }

.search-bar {
  display: flex;
  flex: 1;
  min-width: 260px;
  gap: 8px;
  align-items: center;
}
/* AND/OR mode toggle ‚Äî only shown when 2+ keywords are present */
.mode-toggle {
  display: none;          /* hidden by default; JS sets display:flex */
  align-items: center;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  overflow: hidden;
  flex-shrink: 0;
  font-size: .78rem;
  font-weight: 600;
}
.mode-toggle button {
  padding: 5px 10px;
  background: var(--surface);
  color: var(--muted);
  border: none;
  cursor: pointer;
  transition: background .15s, color .15s;
  line-height: 1;
}
.mode-toggle button.active {
  background: var(--accent);
  color: #fff;
}
.mode-toggle button:first-child {
  border-right: 1px solid var(--border);
}
.tag-input-wrap {
  flex: 1;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 5px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 10px;
  cursor: text;
  transition: border-color .2s;
  min-height: 42px;
}
.tag-input-wrap:focus-within { border-color: var(--accent2); }
.tag-input-wrap input {
  flex: 1;
  min-width: 110px;
  background: transparent;
  border: none;
  color: var(--text);
  font-size: 1rem;
  outline: none;
  padding: 3px 4px;
}
.tag-input-wrap input::placeholder { color: var(--muted); }
.kw-tag {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  background: var(--accent2);
  color: #fff;
  border-radius: 4px;
  padding: 2px 6px 2px 9px;
  font-size: .82rem;
  white-space: nowrap;
  user-select: none;
}
.kw-tag button {
  background: none;
  border: none;
  color: rgba(255,255,255,.7);
  cursor: pointer;
  font-size: 1rem;
  line-height: 1;
  padding: 0;
  margin-left: 1px;
}
.kw-tag button:hover { color: #fff; }

.btn {
  padding: 10px 20px;
  border: none;
  border-radius: var(--radius);
  font-size: .9rem;
  font-weight: 600;
  cursor: pointer;
  transition: opacity .15s, transform .1s;
}
.btn:active { transform: scale(.97); }
.btn:disabled { opacity: .4; cursor: default; }
.btn-primary   { background: linear-gradient(135deg, #3fc5f2, #4fd6ff 48%, #7cf8d6); color: #02242d; box-shadow: 0 8px 18px rgba(79,214,255,.28); }
.btn-secondary { background: linear-gradient(180deg, rgba(25,52,82,.85), rgba(14,31,52,.88)); color: var(--text); border: 1px solid var(--border); }
.btn-blue      { background: linear-gradient(135deg, #7cf8d6, #45d8ff); color: #04323d; box-shadow: 0 8px 18px rgba(83,227,255,.22); }
.btn-danger    { background: #3a1a1a; color: var(--accent); border: 1px solid var(--accent); font-size: .8rem; padding: 5px 10px; }
.btn-sm        { padding: 6px 12px; font-size: .8rem; }

.header-actions { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }

.status-text { font-size: .85rem; color: var(--muted); }

/* ‚îÄ‚îÄ Main ‚îÄ‚îÄ */
.main-cols {
  display: flex;
  flex: 1;
  gap: 0;
  min-height: 0;
}

/* ‚îÄ‚îÄ Sidebar (episodes) ‚îÄ‚îÄ */
.sidebar {
  width: 320px;
  min-width: 280px;
  max-width: 380px;
  background: linear-gradient(180deg, rgba(15,33,56,.9), rgba(10,25,44,.9));
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  flex-shrink: 0;
}
.sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.sidebar-title {
  font-size: .85rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .07em;
  color: var(--muted);
}
.sidebar-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.episode-count {
  font-size: .8rem;
  color: var(--muted);
  padding: 0 16px 10px;
}
.episode-list {
  overflow-y: auto;
  flex: 1;
  padding: 8px 0;
}
.ep-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  transition: background .1s;
}
.ep-item:hover { background: var(--surface); }
.ep-item input[type=checkbox] {
  accent-color: var(--accent2);
  width: 16px; height: 16px;
  flex-shrink: 0;
  cursor: pointer;
}
.ep-info { flex: 1; min-width: 0; }
.ep-title {
  font-size: .83rem;
  color: var(--text);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.ep-meta {
  font-size: .72rem;
  color: var(--muted);
  margin-top: 2px;
}
.ep-delete {
  opacity: 0;
  transition: opacity .15s;
  flex-shrink: 0;
}
.ep-item:hover .ep-delete { opacity: 1; }

.select-all-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border-bottom: 1px solid var(--border);
  font-size: .8rem;
  color: var(--muted);
}
.select-all-row input[type=checkbox] {
  accent-color: var(--accent2);
  width: 15px; height: 15px;
  cursor: pointer;
}

/* ‚îÄ‚îÄ Upload panel ‚îÄ‚îÄ */
/* ‚îÄ‚îÄ Help button ‚îÄ‚îÄ */
.btn-help {
  width: 32px; height: 32px;
  border-radius: 50%;
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--muted);
  font-size: .95rem;
  font-weight: 700;
  cursor: pointer;
  flex-shrink: 0;
  display: flex; align-items: center; justify-content: center;
  transition: border-color .15s, color .15s;
  line-height: 1;
}
.btn-help:hover { border-color: var(--accent2); color: var(--accent2); }

/* ‚îÄ‚îÄ Help modal ‚îÄ‚îÄ */
.help-panel {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.7);
  z-index: 100;
  align-items: center;
  justify-content: center;
}
.help-panel.visible { display: flex; }
.help-box {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 28px 32px;
  width: 600px;
  max-width: 96vw;
  max-height: 90vh;
  overflow-y: auto;
}
.help-box h2 {
  font-size: 1.1rem; font-weight: 700;
  margin-bottom: 20px; color: var(--text);
}
.help-box h3 {
  font-size: .78rem; font-weight: 700;
  text-transform: uppercase; letter-spacing: .07em;
  color: var(--muted); margin: 18px 0 8px;
}
.help-box h3:first-of-type { margin-top: 0; }
.help-box p  { font-size: .88rem; color: var(--text); line-height: 1.6; margin-bottom: 6px; }
.help-box ul { list-style: none; padding: 0; margin-bottom: 6px; }
.help-box ul li {
  font-size: .88rem; color: var(--text); line-height: 1.6;
  padding-left: 16px; position: relative;
}
.help-box ul li::before { content: "¬∑"; position: absolute; left: 4px; color: var(--muted); }
.help-kv {
  display: grid; grid-template-columns: auto 1fr;
  gap: 4px 16px; margin-bottom: 6px;
}
.help-kv .k {
  font-family: monospace; font-size: .82rem;
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 4px; padding: 1px 7px;
  color: var(--accent2); white-space: nowrap; align-self: start;
}
.help-kv .v { font-size: .85rem; color: var(--text); line-height: 1.6; align-self: center; }
.help-divider { border: none; border-top: 1px solid var(--border); margin: 16px 0; }
.help-close-row { display: flex; justify-content: flex-end; margin-top: 22px; }

.upload-panel {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.7);
  z-index: 100;
  align-items: center;
  justify-content: center;
}
.upload-panel.visible { display: flex; }
.upload-box {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 28px;
  width: 520px;
  max-width: 96vw;
  max-height: 90vh;
  overflow-y: auto;
}
.upload-title {
  font-size: 1.1rem;
  font-weight: 700;
  margin-bottom: 18px;
  color: var(--text);
}
.upload-drop-zone {
  border: 2px dashed var(--border);
  border-radius: var(--radius);
  padding: 32px 20px;
  text-align: center;
  cursor: pointer;
  transition: border-color .2s, background .2s;
  margin-bottom: 16px;
}
.upload-drop-zone:hover,
.upload-drop-zone.drag-over {
  border-color: var(--accent2);
  background: rgba(0,180,216,.05);
}
.upload-drop-zone .icon { font-size: 2rem; margin-bottom: 8px; }
.upload-drop-zone p { color: var(--muted); font-size: .9rem; }
.upload-drop-zone strong { color: var(--accent2); cursor: pointer; }
#file-input { display: none; }

/* Queued files list */
.queued-files { margin-bottom: 16px; }
.queued-file {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px 14px;
  margin-bottom: 8px;
}
.queued-file-name { font-size: .85rem; font-weight: 600; margin-bottom: 6px; }
.field-row {
  display: flex;
  gap: 8px;
  margin-bottom: 0;
}
.field-row input {
  flex: 1;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 6px 10px;
  color: var(--text);
  font-size: .82rem;
  outline: none;
}
.field-row input:focus { border-color: var(--accent2); }
.field-row input::placeholder { color: var(--muted); }
.field-row .date-input { flex: 0 0 130px; }

.upload-actions { display: flex; gap: 10px; justify-content: flex-end; }
.upload-progress { font-size: .85rem; color: var(--accent2); margin-top: 12px; }
.upload-result-item { font-size: .8rem; margin-top: 4px; }
.upload-result-item.ok    { color: var(--green); }
.upload-result-item.error { color: var(--accent); }

/* ‚îÄ‚îÄ Content area ‚îÄ‚îÄ */
.content {
  flex: 1;
  padding: 24px;
  overflow-y: auto;
  min-width: 0;
  background: radial-gradient(720px 480px at 10% -5%, rgba(79,214,255,.08), transparent 56%);
}

/* ‚îÄ‚îÄ Cards ‚îÄ‚îÄ */
.card {
  background: linear-gradient(180deg, rgba(20,40,64,.82), rgba(11,25,42,.86));
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-bottom: 20px;
  box-shadow: 0 12px 24px rgba(0,0,0,.22), inset 0 1px 0 rgba(167,234,255,.1);
  backdrop-filter: blur(6px);
}
.card-title {
  font-size: .85rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .07em;
  color: var(--muted);
  margin-bottom: 16px;
}

/* ‚îÄ‚îÄ Stats row ‚îÄ‚îÄ */
.stats-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin-bottom: 20px; }
.stat-card {
  background: linear-gradient(180deg, rgba(24,53,84,.76), rgba(12,30,50,.82));
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 14px 16px;
  text-align: center;
}
.stat-val { font-size: 1.8rem; font-weight: 700; color: var(--accent); }
.stat-val.blue  { color: var(--accent2); }
.stat-val.gold  { color: var(--gold); }
.stat-val.green { color: var(--green); }
.stat-label { font-size: .75rem; color: var(--muted); margin-top: 4px; }

/* ‚îÄ‚îÄ Averages row ‚îÄ‚îÄ */
/* ‚îÄ‚îÄ Threshold checker ‚îÄ‚îÄ */
.threshold-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 20px;
  flex-wrap: wrap;
}
.threshold-label { font-size: .88rem; color: var(--muted); }
.threshold-input {
  width: 68px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  color: var(--text);
  font-size: .95rem;
  font-weight: 600;
  padding: 4px 8px;
  text-align: center;
  outline: none;
  transition: border-color .2s;
  /* hide browser spin buttons */
  -moz-appearance: textfield;
}
.threshold-input::-webkit-outer-spin-button,
.threshold-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
.threshold-input:focus { border-color: var(--accent2); }
.threshold-result {
  font-size: .97rem;
  font-weight: 700;
  color: var(--accent2);
  min-width: 120px;
}
.threshold-result .t-frac { color: var(--muted); font-weight: 400; font-size: .85rem; margin-left: 6px; }

#avgs-container { margin-bottom: 20px; }
.avgs-row { display: flex; gap: 10px; flex-wrap: wrap; }
.avg-kw-block { margin-bottom: 12px; }
.avg-kw-block:last-child { margin-bottom: 0; }
.avg-kw-label, .avg-row-label {
  font-size: .73rem; font-weight: 700; text-transform: uppercase;
  letter-spacing: .07em; color: var(--muted); margin-bottom: 5px;
}
.avg-pill {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 14px;
  font-size: .82rem;
  display: flex;
  flex-direction: column;
  gap: 1px;
  min-width: 88px;
}
.avg-pill .n  { color: var(--muted); font-size: .72rem; }
.avg-pill .v  { font-weight: 700; font-size: .97rem; }
.avg-pill .pm { color: var(--muted); font-size: .72rem; }
.avg-pill.ep1   .v { color: #fff; }
.avg-pill.ep5   .v { color: var(--accent2); }
.avg-pill.ep20  .v { color: #90e0ef; }
.avg-pill.ep50  .v { color: var(--gold); }
.avg-pill.ep100 .v { color: var(--green); }

/* ‚îÄ‚îÄ Charts grid ‚îÄ‚îÄ */
.charts-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
@media (max-width: 900px) { .charts-grid { grid-template-columns: 1fr; } }
.chart-wrap { position: relative; height: 280px; }

/* ‚îÄ‚îÄ Table ‚îÄ‚îÄ */
.table-wrap { overflow-x: auto; }
table { width: 100%; border-collapse: collapse; font-size: .85rem; }
thead th {
  background: var(--surface);
  padding: 10px 12px;
  text-align: left;
  font-size: .75rem;
  text-transform: uppercase;
  letter-spacing: .06em;
  color: var(--muted);
  border-bottom: 1px solid var(--border);
  white-space: nowrap;
}
tbody tr {
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  transition: background .1s;
}
tbody tr:hover { background: var(--surface); }
tbody tr.selected { background: #1e1e3a; }
tbody td { padding: 9px 12px; }
.count-badge {
  display: inline-block;
  background: var(--accent);
  color: #fff;
  border-radius: 4px;
  padding: 1px 7px;
  font-weight: 700;
  font-size: .82rem;
  min-width: 24px;
  text-align: center;
}
.count-badge.zero { background: var(--border); color: var(--muted); }
.ep-num { color: var(--accent2); font-weight: 600; }
.per-min { color: var(--muted); font-size: .8rem; }

/* ‚îÄ‚îÄ Fair value table ‚îÄ‚îÄ */
.fv-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; }
.fv-cell {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  text-align: center;
  transition: border-color .15s, transform .1s;
  cursor: default;
}
.fv-cell:hover { border-color: var(--accent2); transform: translateY(-2px); }
.fv-n { font-size: .75rem; color: var(--muted); margin-bottom: 4px; }
.fv-pct { font-size: 1.5rem; font-weight: 700; color: var(--accent); }
.fv-pct.high   { color: var(--accent); }
.fv-pct.medium { color: var(--gold); }
.fv-pct.low    { color: var(--muted); }
.fv-label { font-size: .7rem; color: var(--muted); margin-top: 3px; }
.fv-model-badge {
  display: inline-block;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 20px;
  padding: 3px 10px;
  font-size: .75rem;
  color: var(--accent2);
  margin-bottom: 14px;
}

/* ‚îÄ‚îÄ Per-minute panel ‚îÄ‚îÄ */
#minute-panel { display: none; }
#minute-panel.visible { display: block; }
#context-panel { display: none; }
#context-panel.visible { display: block; }
.ctx-hit {
  padding: 8px 0;
  border-bottom: 1px solid var(--border);
  font-size: .88rem;
  line-height: 1.55;
}
.ctx-hit:last-child { border-bottom: none; }
.ctx-ts {
  display: inline-block;
  min-width: 52px;
  color: var(--muted);
  font-size: .78rem;
  margin-right: 8px;
  flex-shrink: 0;
}
.ctx-text { color: var(--text-secondary, #ccc); }
.ctx-match {
  background: rgba(233,69,96,.25);
  color: #f87f95;
  border-radius: 3px;
  padding: 0 3px;
  font-weight: 600;
}

/* ‚îÄ‚îÄ Empty / loading states ‚îÄ‚îÄ */
.empty {
  text-align: center;
  padding: 60px 20px;
  color: var(--muted);
}
.empty .icon { font-size: 3rem; margin-bottom: 12px; }
.spinner {
  width: 32px; height: 32px;
  border: 3px solid var(--border);
  border-top-color: var(--accent2);
  border-radius: 50%;
  animation: spin .7s linear infinite;
  margin: 0 auto 12px;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* ‚îÄ‚îÄ Lookback selector ‚îÄ‚îÄ */
.lookback-row { display: flex; align-items: center; gap: 10px; margin-bottom: 16px; flex-wrap: wrap; }
.lookback-row label { font-size: .82rem; color: var(--muted); }
.lookback-row select {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text);
  padding: 5px 10px;
  font-size: .85rem;
  outline: none;
  cursor: pointer;
}

/* ‚îÄ‚îÄ Toast ‚îÄ‚îÄ */
.toast {
  position: fixed;
  bottom: 24px; right: 24px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px 20px;
  font-size: .9rem;
  z-index: 200;
  transform: translateY(80px);
  opacity: 0;
  transition: all .3s;
  max-width: 320px;
}
.toast.show { transform: translateY(0); opacity: 1; }
.toast.success { border-color: var(--green); color: var(--green); }
.toast.error   { border-color: var(--accent); color: var(--accent); }

/* ‚îÄ‚îÄ Results visibility ‚îÄ‚îÄ */
#no-data-msg { display: none; }
#no-data-msg.visible { display: block; }
#results { display: none; }
#results.visible { display: block; }

/* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
@media (max-width: 720px) {
  .main-cols { flex-direction: column; }
  .sidebar { width: 100%; max-width: 100%; border-right: none; border-bottom: 1px solid var(--border); max-height: 260px; }
}
</style>
</head>
<body>
<div class="app">

<!-- ‚îÄ‚îÄ Header ‚îÄ‚îÄ -->
<header>
  <div class="logo">Aero <span>Transcript Analyzer</span></div>

  <div class="search-bar">
    <div class="tag-input-wrap" id="tag-wrap">
      <input type="text" id="search-input" placeholder="Add keyword‚Ä¶ e.g. million" autocomplete="off"/>
    </div>
    <div class="mode-toggle" id="mode-toggle" title="OR ‚Äî sum mentions across keywords&#10;AND ‚Äî only episodes where ALL keywords appear">
      <button id="mode-or"  class="active" onclick="setMode('or')">OR</button>
      <button id="mode-and" onclick="setMode('and')">AND</button>
    </div>
    <button class="btn btn-primary" id="search-btn">Search</button>
    <button class="btn-help" onclick="openHelp()" title="Search help">?</button>
  </div>

  <div class="header-actions">
    <span class="status-text" id="status-text">Loading‚Ä¶</span>
  </div>
</header>

<!-- ‚îÄ‚îÄ Body ‚îÄ‚îÄ -->
<div class="main-cols">

  <!-- ‚îÄ‚îÄ Sidebar: Episodes ‚îÄ‚îÄ -->
  <aside class="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">Episodes</div>
      <div class="sidebar-actions">
        <button class="btn btn-blue btn-sm" id="upload-btn">+ Upload</button>
        <button class="btn btn-secondary btn-sm" id="search-selected-btn">Search selected</button>
      </div>
    </div>

    <div class="select-all-row">
      <input type="checkbox" id="select-all-cb" title="Select / deselect all"/>
      <label for="select-all-cb" style="cursor:pointer">Select all</label>
      <span id="selected-count" style="margin-left:auto;color:var(--accent2)"></span>
    </div>

    <div class="episode-count" id="episode-count"></div>
    <div class="episode-list" id="episode-list">
      <div class="empty" style="padding:30px 20px">
        <div class="icon">üìÇ</div>
        <p>No episodes yet.<br>Upload .txt transcripts to get started.</p>
      </div>
    </div>
  </aside>

  <!-- ‚îÄ‚îÄ Content ‚îÄ‚îÄ -->
  <main class="content">

    <!-- No data -->
    <div id="no-data-msg">
      <div class="empty">
        <div class="icon">üîç</div>
        <h2 style="margin-bottom:10px">Upload transcripts to begin</h2>
        <p style="color:var(--muted)">Click <strong>+ Upload</strong> in the sidebar to add .txt transcript files,<br>then search for any keyword.</p>
      </div>
    </div>

    <!-- Results -->
    <div id="results">

      <!-- Stats row -->
      <div class="stats-row">
        <div class="stat-card">
          <div class="stat-val" id="stat-total">‚Äì</div>
          <div class="stat-label">Total mentions</div>
        </div>
        <div class="stat-card">
          <div class="stat-val blue" id="stat-episodes">‚Äì</div>
          <div class="stat-label">Episodes searched</div>
        </div>
        <div class="stat-card">
          <div class="stat-val gold" id="stat-avg1">‚Äì</div>
          <div class="stat-label">Avg last episode</div>
        </div>
        <div class="stat-card">
          <div class="stat-val green" id="stat-avg20">‚Äì</div>
          <div class="stat-label">Avg last 20 eps</div>
        </div>
      </div>

      <!-- Averages pills -->
      <div id="avgs-container"></div>

      <!-- Threshold checker -->
      <div class="threshold-row" id="threshold-row" style="display:none">
        <span class="threshold-label">Episodes with</span>
        <span class="threshold-label">‚â•</span>
        <input type="number" id="threshold-input" class="threshold-input" min="1" step="1" placeholder="N">
        <span class="threshold-label" id="threshold-mode-label">mentions:</span>
        <span id="threshold-result" class="threshold-result">‚Äî</span>
      </div>

      <!-- Charts grid -->
      <div class="charts-grid">
        <div class="card">
          <div class="card-title" data-trend-title>Mentions per episode</div>
          <div class="chart-wrap"><canvas id="trend-chart"></canvas></div>
        </div>
        <div class="card">
          <div class="card-title" data-fv-chart>Polymarket fair value ‚Äî next episode</div>
          <div class="lookback-row">
            <label>Lookback:</label>
            <select id="lookback-sel">
              <option value="5">Last 5</option>
              <option value="10">Last 10</option>
              <option value="20" selected>Last 20</option>
              <option value="50">Last 50</option>
              <option value="100">Last 100</option>
            </select>
            <span id="fv-model-badge" class="fv-model-badge"></span>
          </div>
          <div class="chart-wrap"><canvas id="fv-chart"></canvas></div>
        </div>
      </div>

      <!-- Fair value grid -->
      <div class="card">
        <div class="card-title" data-fv-grid>Fair value ‚Äî P(‚â• N mentions) in next episode</div>
        <div class="fv-grid" id="fv-grid"></div>
      </div>

      <!-- Per-minute panel -->
      <div class="card" id="minute-panel">
        <div class="card-title" id="minute-title">Per-minute breakdown</div>
        <div class="chart-wrap" style="height:220px"><canvas id="minute-chart"></canvas></div>
      </div>

      <!-- Context / KWIC panel -->
      <div class="card" id="context-panel">
        <div class="card-title" id="context-title">Transcript mentions</div>
        <div id="context-hits"></div>
      </div>

      <!-- Episode table -->
      <div class="card">
        <div class="card-title">Episode history ‚Äî click a row for per-minute breakdown &amp; transcript hits</div>
        <div class="table-wrap">
          <table id="ep-table">
            <thead>
              <tr>
                <th>Episode</th>
                <th>Date</th>
                <th>Mentions</th>
                <th>Per min</th>
                <th>Title</th>
              </tr>
            </thead>
            <tbody id="ep-tbody"></tbody>
          </table>
        </div>
      </div>

    </div><!-- /results -->
  </main>
</div><!-- /main-cols -->
</div><!-- /app -->

<!-- ‚îÄ‚îÄ Help modal ‚îÄ‚îÄ -->
<div class="help-panel" id="help-panel" onclick="if(event.target===this)closeHelp()">
  <div class="help-box">
    <h2>How search works</h2>

    <h3>Adding keywords</h3>
    <p>Type a word and press <strong>Enter</strong> or <strong>,</strong> to add it as a chip. Add multiple chips to search across keywords at once. Press <strong>Backspace</strong> to remove the last chip.</p>

    <h3>OR vs AND mode</h3>
    <div class="help-kv">
      <span class="k">OR</span><span class="v">Count every episode that mentions <em>any</em> keyword. Total = sum of all keyword occurrences.</span>
      <span class="k">AND</span><span class="v">Only count episodes where <em>every</em> keyword appears at least once.</span>
    </div>

    <hr class="help-divider">

    <h3>What counts as a match</h3>
    <div class="help-kv">
      <span class="k">Exact</span><span class="v">The word itself ‚Äî <em>drug</em> matches "drug".</span>
      <span class="k">Plural</span><span class="v"><em>+s</em> or <em>+es</em> ‚Äî "drugs", "asses" match their base terms. Verb conjugations like "collapses" do <strong>not</strong> count as a plural of "collapse".</span>
      <span class="k">Compound</span><span class="v">The term used as one component of a compound word. "killjoy" and "badass" count for "joy" and "ass". Derivational forms like "joyful" or "joyfully" do <strong>not</strong> count.</span>
    </div>

    <h3>Adjacent keywords count once</h3>
    <p>When two searched keywords appear next to each other in the transcript ‚Äî e.g. searching <strong>Joe, Biden</strong> and the transcript says "Joe Biden" ‚Äî that adjacent pair counts as <strong>one</strong> mention, not two. Non-adjacent occurrences each count separately.</p>

    <h3>What's excluded</h3>
    <ul>
      <li>The standard intro marker line and all text before it are ignored.</li>
      <li>Words embedded inside unrelated longer words are filtered out ‚Äî e.g. "parliament" does not count for "amen", "embarrassing" does not count for "ass".</li>
      <li>Number words (thirteen ‚Äì nineteen) do not count for "teen".</li>
    </ul>

    <h3>Phrases</h3>
    <p>Type a multi-word phrase as a single chip (e.g. <em>prime minister</em>) to search for that exact sequence of words.</p>

    <div class="help-close-row">
      <button class="btn btn-secondary" onclick="closeHelp()">Close</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ Upload panel ‚îÄ‚îÄ -->
<div class="upload-panel" id="upload-panel">
  <div class="upload-box">
    <div class="upload-title">Upload Transcripts</div>

    <div class="upload-drop-zone" id="drop-zone">
      <div class="icon">üìÑ</div>
      <p>Drag &amp; drop .txt files here<br>or <strong id="browse-link">browse</strong></p>
      <input type="file" id="file-input" accept=".txt" multiple/>
    </div>

    <div class="queued-files" id="queued-files"></div>

    <div class="upload-actions">
      <button class="btn btn-secondary" id="upload-cancel-btn">Cancel</button>
      <button class="btn btn-primary" id="upload-submit-btn" disabled>Upload</button>
    </div>

    <div id="upload-progress" class="upload-progress" style="display:none"></div>
    <div id="upload-results"></div>
  </div>
</div>

<!-- ‚îÄ‚îÄ Toast ‚îÄ‚îÄ -->
<div class="toast" id="toast"></div>

<script>
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// State
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let allEpisodes   = [];   // [{id, title, episode_date, ...}]
let selectedIds   = new Set();  // episode IDs checked in sidebar
let currentData   = null;
let currentKeyword = "";

// Colour palette for multi-keyword charts (stacked bars)
const KW_COLORS = ["#e94560","#a855f7","#f97316","#ec4899","#3b82f6","#14b8a6","#eab308"];
let trendChart    = null;
let fvChart       = null;
let minuteChart   = null;
let queuedFiles   = [];   // [{file, title, date}]

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Boot
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.addEventListener("DOMContentLoaded", () => {
  loadEpisodes();

  document.getElementById("search-btn").addEventListener("click", doSearch);

  // Tag-chip input: Enter/comma adds a chip; Backspace removes last chip
  document.getElementById("tag-wrap").addEventListener("click", () =>
    document.getElementById("search-input").focus()
  );
  document.getElementById("search-input").addEventListener("keydown", e => {
    const inp = e.target;
    if (e.key === "Enter") {
      if (inp.value.trim()) { addKwTag(inp.value); }
      else { doSearch(); }
    } else if (e.key === ",") {
      e.preventDefault();
      addKwTag(inp.value);
    } else if (e.key === "Backspace" && inp.value === "") {
      const chips = document.querySelectorAll(".kw-tag");
      if (chips.length) chips[chips.length - 1].remove();
      updateSearchPlaceholder();
    }
  });
  document.getElementById("search-input").addEventListener("input", updateModeToggleVisibility);
  document.getElementById("lookback-sel").addEventListener("change", () => {
    if (currentKeyword) doSearch();
  });

  // Sidebar
  document.getElementById("upload-btn").addEventListener("click", openUpload);
  document.getElementById("search-selected-btn").addEventListener("click", doSearch);
  document.getElementById("select-all-cb").addEventListener("change", toggleSelectAll);

  // Upload panel
  document.getElementById("upload-cancel-btn").addEventListener("click", closeUpload);
  document.getElementById("upload-submit-btn").addEventListener("click", submitUpload);
  document.getElementById("browse-link").addEventListener("click", () =>
    document.getElementById("file-input").click()
  );
  document.getElementById("drop-zone").addEventListener("click", e => {
    if (e.target.id !== "browse-link") document.getElementById("file-input").click();
  });
  document.getElementById("file-input").addEventListener("change", e =>
    addFiles(Array.from(e.target.files))
  );

  // Drag-and-drop
  const dz = document.getElementById("drop-zone");
  dz.addEventListener("dragover", e => { e.preventDefault(); dz.classList.add("drag-over"); });
  dz.addEventListener("dragleave", () => dz.classList.remove("drag-over"));
  dz.addEventListener("drop", e => {
    e.preventDefault();
    dz.classList.remove("drag-over");
    addFiles(Array.from(e.dataTransfer.files).filter(f => f.name.endsWith(".txt")));
  });
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Load episodes from server
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function loadEpisodes() {
  try {
    const r = await fetch("/api/episodes");
    allEpisodes = await r.json();
    // Default: all selected
    selectedIds = new Set(allEpisodes.map(e => e.id));
    renderSidebar();
    updateStatus();
  } catch {
    document.getElementById("status-text").textContent = "Server unreachable";
  }
}

function updateStatus() {
  const total = allEpisodes.length;
  document.getElementById("status-text").textContent =
    total === 0 ? "No episodes uploaded" : `${total} episode${total !== 1 ? "s" : ""} in database`;

  if (total === 0) {
    document.getElementById("no-data-msg").classList.add("visible");
    document.getElementById("results").classList.remove("visible");
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Sidebar
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderSidebar() {
  const list = document.getElementById("episode-list");
  const countEl = document.getElementById("episode-count");

  if (allEpisodes.length === 0) {
    list.innerHTML = `<div class="empty" style="padding:30px 20px">
      <div class="icon">üìÇ</div>
      <p>No episodes yet.<br>Upload .txt transcripts to get started.</p>
    </div>`;
    countEl.textContent = "";
    document.getElementById("selected-count").textContent = "";
    return;
  }

  countEl.textContent = `${allEpisodes.length} episode${allEpisodes.length !== 1 ? "s" : ""}`;
  updateSelectedCount();

  list.innerHTML = allEpisodes.map(ep => {
    const checked = selectedIds.has(ep.id) ? "checked" : "";
    const num = ep.episode_number ? `#${ep.episode_number} ¬∑ ` : "";
    const date = ep.episode_date || ep.uploaded_at?.slice(0, 10) || "";
    const dur  = ep.duration_seconds > 0 ? ` ¬∑ ${Math.round(ep.duration_seconds / 60)}m` : "";
    const title = (ep.title || "").slice(0, 45) + ((ep.title || "").length > 45 ? "‚Ä¶" : "");
    return `<div class="ep-item" data-id="${ep.id}">
      <input type="checkbox" ${checked} data-id="${ep.id}" onclick="toggleEpisode(event,${ep.id})"/>
      <div class="ep-info">
        <div class="ep-title">${escHtml(title)}</div>
        <div class="ep-meta">${num}${date}${dur}</div>
      </div>
      <button class="btn btn-danger ep-delete" onclick="deleteEpisode(event,${ep.id})" title="Delete">‚úï</button>
    </div>`;
  }).join("");

  // Sync select-all checkbox
  const allChecked = allEpisodes.every(e => selectedIds.has(e.id));
  const noneChecked = allEpisodes.every(e => !selectedIds.has(e.id));
  const cb = document.getElementById("select-all-cb");
  cb.checked = allChecked;
  cb.indeterminate = !allChecked && !noneChecked;
}

function toggleEpisode(event, id) {
  event.stopPropagation();
  if (selectedIds.has(id)) {
    selectedIds.delete(id);
  } else {
    selectedIds.add(id);
  }
  updateSelectedCount();
  // Sync select-all checkbox
  const allChecked = allEpisodes.every(e => selectedIds.has(e.id));
  const noneChecked = allEpisodes.every(e => !selectedIds.has(e.id));
  const cb = document.getElementById("select-all-cb");
  cb.checked = allChecked;
  cb.indeterminate = !allChecked && !noneChecked;
}

function toggleSelectAll() {
  const cb = document.getElementById("select-all-cb");
  if (cb.checked) {
    selectedIds = new Set(allEpisodes.map(e => e.id));
  } else {
    selectedIds = new Set();
  }
  renderSidebar();
}

function updateSelectedCount() {
  const n = selectedIds.size;
  const total = allEpisodes.length;
  document.getElementById("selected-count").textContent =
    n === total ? "" : `${n} selected`;
}

async function deleteEpisode(event, id) {
  event.stopPropagation();
  if (!confirm("Delete this episode and all its data?")) return;
  try {
    const r = await fetch(`/api/episode/${id}`, { method: "DELETE" });
    if (!r.ok) throw new Error("Delete failed");
    allEpisodes = allEpisodes.filter(e => e.id !== id);
    selectedIds.delete(id);
    renderSidebar();
    updateStatus();
    toast("Episode deleted", "success");
  } catch (e) {
    toast(e.message, "error");
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Upload panel
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function openUpload() {
  queuedFiles = [];
  document.getElementById("queued-files").innerHTML = "";
  document.getElementById("upload-submit-btn").disabled = true;
  document.getElementById("file-input").value = "";
  document.getElementById("upload-progress").style.display = "none";
  document.getElementById("upload-results").innerHTML = "";
  document.getElementById("upload-panel").classList.add("visible");
}

function closeUpload() {
  document.getElementById("upload-panel").classList.remove("visible");
}

function openHelp()  { document.getElementById("help-panel").classList.add("visible"); }
function closeHelp() { document.getElementById("help-panel").classList.remove("visible"); }
document.addEventListener("keydown", e => { if (e.key === "Escape") closeHelp(); });

function addFiles(files) {
  files.forEach(f => {
    if (!f.name.endsWith(".txt")) return;
    queuedFiles.push({ file: f, title: "" });
  });
  renderQueuedFiles();
  document.getElementById("upload-submit-btn").disabled = queuedFiles.length === 0;
}

function renderQueuedFiles() {
  const container = document.getElementById("queued-files");
  if (queuedFiles.length === 0) {
    container.innerHTML = "";
    return;
  }
  container.innerHTML = queuedFiles.map((item, i) => `
    <div class="queued-file" data-index="${i}">
      <div class="queued-file-name">üìÑ ${escHtml(item.file.name)}</div>
      <div class="field-row">
        <input type="text"
               placeholder="Episode title (optional)"
               value="${escHtml(item.title)}"
               oninput="queuedFiles[${i}].title=this.value"/>
      </div>
    </div>
  `).join("");
}

async function submitUpload() {
  if (queuedFiles.length === 0) return;

  const btn = document.getElementById("upload-submit-btn");
  const prog = document.getElementById("upload-progress");
  const resultsEl = document.getElementById("upload-results");

  btn.disabled = true;
  prog.style.display = "block";
  prog.textContent = `Uploading ${queuedFiles.length} file(s)‚Ä¶`;
  resultsEl.innerHTML = "";

  const fd = new FormData();
  queuedFiles.forEach(item => {
    fd.append("files[]", item.file, item.file.name);
    fd.append("title[]", item.title || item.file.name.replace(/\.txt$/i, ""));
  });

  try {
    const r = await fetch("/api/upload", { method: "POST", body: fd });
    const data = await r.json();

    let html = "";
    (data.created || []).forEach(ep => {
      html += `<div class="upload-result-item ok">‚úì ${escHtml(ep.title)} ‚Äî ${ep.segment_count} segments</div>`;
    });
    (data.errors || []).forEach(err => {
      html += `<div class="upload-result-item error">‚úó ${escHtml(err.filename)}: ${escHtml(err.error)}</div>`;
    });
    resultsEl.innerHTML = html;

    prog.textContent = `Done. ${(data.created||[]).length} uploaded, ${(data.errors||[]).length} errors.`;

    if ((data.created || []).length > 0) {
      await loadEpisodes();
      toast(`${data.created.length} episode(s) uploaded`, "success");
    }

    queuedFiles = [];
    btn.disabled = true;
  } catch (e) {
    prog.textContent = "Upload failed: " + e.message;
    toast("Upload failed", "error");
    btn.disabled = false;
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚îÄ‚îÄ Tag-chip keyword helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// ‚îÄ‚îÄ AND / OR mode toggle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let searchMode = "or";   // "or" | "and"

function setMode(m) {
  searchMode = m;
  document.getElementById("mode-or").classList.toggle("active",  m === "or");
  document.getElementById("mode-and").classList.toggle("active", m === "and");
}

function updateModeToggleVisibility() {
  const chips = document.querySelectorAll(".kw-tag").length;
  const cur   = document.getElementById("search-input").value.trim();
  // Show when ‚â•2 keywords are present (chips + possibly one in the input box)
  const total = chips + (cur ? 1 : 0);
  document.getElementById("mode-toggle").style.display = total >= 2 ? "flex" : "none";
}

function updateSearchPlaceholder() {
  const inp = document.getElementById("search-input");
  const hasChips = document.querySelectorAll(".kw-tag").length > 0;
  inp.placeholder = hasChips ? "Add another keyword‚Ä¶" : "Add keyword‚Ä¶ e.g. million";
  updateModeToggleVisibility();
}

function addKwTag(raw) {
  // Split only on commas ‚Äî spaces are kept so phrases like "prime minister" stay intact.
  const terms = raw.split(/,+/).map(t => t.trim()).filter(Boolean);
  if (!terms.length) return;
  const existing = () => [...document.querySelectorAll(".kw-tag")].map(el => el.dataset.kw.toLowerCase());
  const inp = document.getElementById("search-input");
  const wrap = document.getElementById("tag-wrap");
  terms.forEach(kw => {
    if (existing().includes(kw.toLowerCase())) return;
    const chip = document.createElement("span");
    chip.className = "kw-tag";
    chip.dataset.kw = kw;
    chip.innerHTML = `${escHtml(kw)} <button aria-label="remove">√ó</button>`;
    chip.querySelector("button").addEventListener("click", () => {
      chip.remove();
      updateSearchPlaceholder();
    });
    wrap.insertBefore(chip, inp);
  });
  inp.value = "";
  updateSearchPlaceholder();
}

function getKeywords() {
  const chips = [...document.querySelectorAll(".kw-tag")].map(el => el.dataset.kw);
  const cur = document.getElementById("search-input").value.trim().replace(/,+$/, "").trim();
  if (cur) chips.push(cur);
  return chips.filter(Boolean);
}

// Search
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function doSearch() {
  const keywords = getKeywords();
  if (!keywords.length) { toast("Enter at least one keyword", "error"); return; }
  if (allEpisodes.length === 0) { toast("Upload transcripts first", "error"); return; }

  const kw = keywords.join(", ");
  const lookback = document.getElementById("lookback-sel").value;
  currentKeyword = kw;

  // Determine episode filter
  const allSelected = selectedIds.size === allEpisodes.length;
  const episodeIdsParam = allSelected
    ? ""
    : Array.from(selectedIds).join(",");

  if (selectedIds.size === 0) { toast("Select at least one episode", "error"); return; }

  const btn = document.getElementById("search-btn");
  btn.disabled = true;
  btn.textContent = "Searching‚Ä¶";

  try {
    const multi = keywords.length > 1;
    const mode  = multi ? searchMode : "or";
    let url = `/api/search?keyword=${encodeURIComponent(kw)}&lookback=${lookback}&mode=${mode}`;
    if (episodeIdsParam) url += `&episode_ids=${episodeIdsParam}`;

    const r = await fetch(url);
    if (!r.ok) { const e = await r.json(); throw new Error(e.error || r.statusText); }
    const data = await r.json();
    currentData = data;
    renderResults(data);
    document.getElementById("results").classList.add("visible");
    document.getElementById("no-data-msg").classList.remove("visible");
  } catch (e) {
    toast(e.message, "error");
  } finally {
    btn.disabled = false;
    btn.textContent = "Search";
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Render
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderResults(data) {
  const eps  = data.episodes;
  const avgs = data.averages;
  const fv   = data.fair_value;

  const total = eps.reduce((s, e) => s + e.count, 0);
  document.getElementById("stat-total").textContent    = total;
  document.getElementById("stat-episodes").textContent = eps.length;
  document.getElementById("stat-avg1").textContent     = fmt(avgs.last_1);
  document.getElementById("stat-avg20").textContent    = fmt(avgs.last_20);

  // Average pills
  const isAnd = data.mode === "and" && (data.per_keyword || []).length > 1;
  const isMultiOr = data.mode !== "and" && (data.per_keyword || []).length > 1;

  const fmtPm = v => (v !== null && v !== undefined) ? `${Number(v).toFixed(3)}/min` : "‚Äî";
  const makePills = (a, apm) => {
    const defs = [
      {cls:"ep1",   n:"Last 1",   v: a.last_1,   pm: apm.last_1},
      {cls:"ep5",   n:"Last 5",   v: a.last_5,   pm: apm.last_5},
      {cls:"ep20",  n:"Last 20",  v: a.last_20,  pm: apm.last_20},
      {cls:"ep50",  n:"Last 50",  v: a.last_50,  pm: apm.last_50},
      {cls:"ep100", n:"Last 100", v: a.last_100, pm: apm.last_100},
    ];
    return defs.map(p =>
      `<div class="avg-pill ${p.cls}">
         <span class="n">${p.n}</span>
         <span class="v">${fmt(p.v)}</span>
         <span class="pm">${fmtPm(p.pm)}</span>
       </div>`
    ).join("");
  };

  let avgsHtml;
  if (isMultiOr) {
    // OR multi-keyword: one pill row per keyword
    avgsHtml = (data.per_keyword || []).map(kw =>
      `<div class="avg-kw-block">
         <div class="avg-kw-label">${escHtml(kw.keyword)}</div>
         <div class="avgs-row">${makePills(kw.averages, kw.averages_per_min)}</div>
       </div>`
    ).join("");
  } else {
    // Single keyword or AND mode: one row (labelled for AND)
    const label = isAnd ? `<div class="avg-row-label">Co-occurrence average</div>` : "";
    avgsHtml = `${label}<div class="avgs-row">${makePills(avgs, data.averages_per_min)}</div>`;
  }
  document.getElementById("avgs-container").innerHTML = avgsHtml;

  // Threshold checker
  document.getElementById("threshold-row").style.display = "flex";
  document.getElementById("threshold-input").value = "";
  document.getElementById("threshold-result").innerHTML = "‚Äî";
  document.getElementById("threshold-mode-label").textContent =
    isAnd     ? "combined co-occurrence mentions:"
    : isMultiOr ? "combined mentions:"
    : "mentions:";

  // Set of episode IDs where co-occurrence happened (AND mode only)
  const coOccurIds = isAnd
    ? new Set(data.episodes.filter(e => e.count > 0).map(e => e.episode_id))
    : null;

  renderTrendChart(eps, data.per_keyword, isAnd, coOccurIds);

  const modelLabel = {
    "poisson":       "Poisson",
    "empirical":     "Empirical",
    "neg-binomial":  "Neg-Binomial",
    "zero-inflated": "Zero-Inflated NB",
  }[fv.model] || fv.model;
  const piSuffix = (fv.model === "zero-inflated" && fv.pi_estimate != null)
    ? `  œÄ=${(fv.pi_estimate * 100).toFixed(0)}%`
    : "";
  document.getElementById("fv-model-badge").textContent = modelLabel + piSuffix;

  // Update all card titles to reflect AND co-occurrence mode
  document.querySelector(".card-title[data-trend-title]").textContent =
    isAnd ? "Co-occurrence mentions per episode" : "Mentions per episode";
  document.querySelector(".card-title[data-fv-chart]").textContent =
    isAnd ? "Polymarket fair value ‚Äî co-occurrence next episode" : "Polymarket fair value ‚Äî next episode";
  document.querySelector(".card-title[data-fv-grid]").textContent =
    isAnd ? "Fair value ‚Äî P(both words in ‚â• N mentions) next episode" : "Fair value ‚Äî P(‚â• N mentions) in next episode";

  // In AND mode show the single merged FV bar (co-occurrence FV);
  // in OR mode show per-keyword grouped bars.
  renderFVChart(fv, isAnd ? null : data.per_keyword_fv);
  renderFVGrid(fv);
  renderTable(eps);

  document.getElementById("minute-panel").classList.remove("visible");
  if (minuteChart) { minuteChart.destroy(); minuteChart = null; }
}

// ‚îÄ‚îÄ Trend chart ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderTrendChart(episodes, perKeyword, isAnd, coOccurIds) {
  const ctx = document.getElementById("trend-chart").getContext("2d");
  if (trendChart) trendChart.destroy();

  const eps    = [...episodes].reverse();
  const labels = eps.map(e => e.episode_number ? `#${e.episode_number}` : (e.episode_date || `ID${e.episode_id}`));
  const mergedCounts = eps.map(e => e.count);
  const isMultiKeyword = perKeyword && perKeyword.length > 1;
  // Stack only in AND mode. In OR mode, show grouped component bars and
  // a deduped merged line so the final combined count remains visible.
  const stacked = !!(isMultiKeyword && isAnd);

  let barDatasets;
  if (isMultiKeyword) {
    barDatasets = perKeyword.map((kw, i) => {
      const col = KW_COLORS[i % KW_COLORS.length];
      const idxMap = Object.fromEntries(kw.episodes.map(e => [e.episode_id, e.count]));
      const counts = eps.map(e =>
        (isAnd && coOccurIds && !coOccurIds.has(e.episode_id)) ? 0 : (idxMap[e.episode_id] ?? 0)
      );
      return {
        label: kw.keyword,
        data: counts,
        backgroundColor: col + "cc",
        borderColor: col,
        borderWidth: 1,
        borderRadius: 3,
        type: "bar",
        order: 2,
        stack: stacked ? "kw" : undefined,
      };
    });
  } else {
    const col = KW_COLORS[0];
    const label = perKeyword && perKeyword.length === 1 ? perKeyword[0].keyword : "Mentions";
    barDatasets = [{
      label, data: mergedCounts,
      backgroundColor: mergedCounts.map(c => c > 0 ? col + "cc" : "#2a2a4a"),
      borderColor:     mergedCounts.map(c => c > 0 ? col       : "#2a2a4a"),
      borderWidth: 1, borderRadius: 3, type: "bar", order: 2,
    }];
  }

  const rolling20 = mergedCounts.map((_, i) => {
    const start = Math.max(0, i - 19);
    const window = mergedCounts.slice(start, i + 1);
    return window.reduce((a, b) => a + b, 0) / window.length;
  });

  const lineDatasets = [
    {
      label: "Rolling avg (20 eps)",
      data: rolling20,
      type: "line",
      borderColor: "#ffd166",
      backgroundColor: "#ffd166",
      borderWidth: 2,
      pointRadius: 0,
      tension: 0.25,
      order: 0,
    }
  ];

  if (isMultiKeyword && !isAnd) {
    lineDatasets.push({
      label: "Combined (deduped)",
      data: mergedCounts,
      type: "line",
      borderColor: "#ffffff",
      backgroundColor: "#ffffff",
      borderWidth: 1.8,
      pointRadius: 0,
      tension: 0.2,
      order: 1,
    });
  }

  trendChart = new Chart(ctx, {
    data: { labels, datasets: [...barDatasets, ...lineDatasets] },
    options: {
      responsive: true, maintainAspectRatio: false,
      animation: { duration: 300 },
      plugins: {
        legend: { labels: { color: "#aaa", font: { size: 11 }, boxWidth: 18, padding: 10 }, position: "top" },
        tooltip: {
          callbacks: {
            title: items => { const i = items[0].dataIndex; return eps[i].title?.slice(0,50) || labels[i]; },
            label: item => `${item.dataset.label}: ${Number(item.raw).toFixed(2)}`,
          }
        }
      },
      scales: {
        x: { ticks: { color: "#888", maxRotation: 45, font: { size: 10 }, maxTicksLimit: 25 }, grid: { color: "#22223a" }, stacked },
        y: { ticks: { color: "#888" }, grid: { color: "#22223a" }, beginAtZero: true, stacked }
      }
    }
  });
}

// ‚îÄ‚îÄ Fair-value chart ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderFVChart(fv, pkFv) {
  const ctx = document.getElementById("fv-chart").getContext("2d");
  if (fvChart) fvChart.destroy();

  const labels   = fv.buckets.map(b => b.label);
  const multiKw  = pkFv && pkFv.length > 1;

  // AND mode (pkFv===null): single merged co-occurrence bar in a distinct teal colour.
  // OR multi-kw mode: one grouped bar per keyword.
  // Single keyword: single bar.
  const isAndMode = pkFv === null;
  const AND_COLOR = "#06d6a0";

  const datasets = multiKw
    ? pkFv.map((kw, i) => {
        const col = KW_COLORS[i % KW_COLORS.length];
        return {
          label: kw.keyword,
          data: kw.buckets.map(b => b.pct),
          backgroundColor: col + "cc",
          borderColor: col,
          borderWidth: 1, borderRadius: 3,
        };
      })
    : [{
        label: isAndMode ? "co-occurrence" : (pkFv && pkFv.length === 1 ? pkFv[0].keyword : "P(‚â• N) %"),
        data: fv.buckets.map(b => b.pct),
        backgroundColor: (isAndMode ? AND_COLOR : KW_COLORS[0]) + "cc",
        borderColor: isAndMode ? AND_COLOR : KW_COLORS[0],
        borderWidth: 1, borderRadius: 4,
      }];

  fvChart = new Chart(ctx, {
    type: "bar",
    data: { labels, datasets },
    options: {
      responsive: true, maintainAspectRatio: false, animation: { duration: 300 },
      plugins: {
        legend: { display: multiKw || isAndMode, labels: { color: "#aaa", font: { size: 10 }, boxWidth: 14, padding: 8 }, position: "top" },
        tooltip: { callbacks: { label: item => `${item.dataset.label}: P(‚â•${item.label}) = ${item.raw.toFixed(1)}%` } },
      },
      scales: {
        x: { ticks: { color: "#888" }, grid: { color: "#22223a" } },
        y: { ticks: { color: "#888", callback: v => v + "%" }, grid: { color: "#22223a" }, beginAtZero: true, max: 100 }
      }
    }
  });
}

// ‚îÄ‚îÄ FV grid ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderFVGrid(fv) {
  document.getElementById("fv-grid").innerHTML = fv.buckets.map(b => {
    const pct = b.pct;
    const cls = pct >= 30 ? "high" : pct >= 10 ? "medium" : "low";
    return `<div class="fv-cell">
      <div class="fv-n">‚â• ${b.label} mention${b.n !== 1 ? "s" : ""}</div>
      <div class="fv-pct ${cls}">${pct.toFixed(1)}%</div>
      <div class="fv-label">P(mentions ‚â• ${b.label})</div>
    </div>`;
  }).join("");
}

// ‚îÄ‚îÄ Episode table ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderTable(episodes) {
  const tbody = document.getElementById("ep-tbody");
  tbody.innerHTML = episodes.map(ep => {
    const num   = ep.episode_number ? `#${ep.episode_number}` : `ID${ep.episode_id}`;
    const badge = ep.count > 0
      ? `<span class="count-badge">${ep.count}</span>`
      : `<span class="count-badge zero">0</span>`;
    const pm    = ep.per_minute > 0 ? `<span class="per-min">${ep.per_minute.toFixed(3)}/min</span>` : "";
    const title = (ep.title || "").slice(0, 55) + ((ep.title || "").length > 55 ? "‚Ä¶" : "");
    return `<tr data-eid="${ep.episode_id}">
      <td class="ep-num">${num}</td>
      <td>${ep.episode_date || "‚Äî"}</td>
      <td>${badge}</td>
      <td>${pm}</td>
      <td>${escHtml(title)}</td>
    </tr>`;
  }).join("");

  tbody.querySelectorAll("tr").forEach(row => {
    row.addEventListener("click", () => {
      tbody.querySelectorAll("tr").forEach(r => r.classList.remove("selected"));
      row.classList.add("selected");
      loadMinutes(parseInt(row.dataset.eid));
    });
  });
}

// ‚îÄ‚îÄ Per-minute breakdown ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function loadMinutes(episodeId) {
  if (!currentKeyword) return;
  loadContext(episodeId);
  try {
    const mode = (currentData && currentData.mode) || "or";
    const r = await fetch(`/api/minutes?keyword=${encodeURIComponent(currentKeyword)}&episode_id=${episodeId}&mode=${mode}`);
    const d = await r.json();

    const panel = document.getElementById("minute-panel");
    panel.classList.add("visible");
    document.getElementById("minute-title").textContent =
      `Per-minute ‚Äî ${(d.title || String(episodeId)).slice(0, 60)}`;

    const ctx = document.getElementById("minute-chart").getContext("2d");
    if (minuteChart) minuteChart.destroy();

    if (!d.minutes || d.minutes.length === 0) {
      panel.querySelector("canvas").style.display = "none";
      document.getElementById("minute-title").textContent += "  (no mentions)";
      return;
    }
    panel.querySelector("canvas").style.display = "";

    const labels  = d.minutes.map(m => `${m.minute}m`);
    const counts  = d.minutes.map(m => m.count);
    const mean    = counts.reduce((a, b) => a + b, 0) / counts.length;
    const pk      = d.per_keyword;
    const isAndMode = currentData && currentData.mode === "and";
    const isMultiKeyword = pk && pk.length > 1;
    // AND mode can stack cleanly. OR mode is adjacency-deduped, so we show
    // color-separated component bars plus a deduped total line.
    const stacked = !!(isMultiKeyword && isAndMode);

    let barDatasets;
    if (isMultiKeyword) {
      barDatasets = pk.map((kw, i) => {
        const col  = KW_COLORS[i % KW_COLORS.length];
        const data = d.minutes.map(m => kw.minutes[m.minute] ?? 0);
        return {
          label: kw.keyword,
          data,
          backgroundColor: col + "cc",
          borderColor: col,
          borderWidth: 1,
          borderRadius: 3,
          order: 2,
          stack: stacked ? "kw" : undefined,
        };
      });
    } else {
      const col   = KW_COLORS[0];
      const label = pk && pk.length === 1 ? pk[0].keyword : "Mentions";
      barDatasets = [{ label, data: counts, backgroundColor: col + "cc", borderColor: col,
                       borderWidth: 1, borderRadius: 3, order: 2 }];
    }

    const lineDatasets = [
      { label: `Avg ${mean.toFixed(2)}/min`, data: Array(counts.length).fill(mean),
        type: "line", borderColor: "#ffd166", borderWidth: 1.5, borderDash: [4,4], pointRadius: 0, order: 1 }
    ];

    if (isMultiKeyword && !isAndMode) {
      lineDatasets.push({
        label: "Combined (deduped)",
        data: counts,
        type: "line",
        borderColor: "#ffffff",
        backgroundColor: "#ffffff",
        borderWidth: 1.8,
        pointRadius: 0,
        tension: 0.2,
        order: 0,
      });
    }

    minuteChart = new Chart(ctx, {
      type: "bar",
      data: { labels, datasets: [
        ...barDatasets,
        ...lineDatasets,
      ]},
      options: {
        responsive: true, maintainAspectRatio: false, animation: { duration: 200 },
        plugins: { legend: { labels: { color: "#aaa", font: { size: 10 }, boxWidth: 14 } } },
        scales: {
          x: { ticks: { color: "#888", font: { size: 10 }, maxTicksLimit: 30 }, grid: { color: "#22223a" }, stacked },
          y: { ticks: { color: "#888" }, grid: { color: "#22223a" }, beginAtZero: true, stacked }
        }
      }
    });

    panel.scrollIntoView({ behavior: "smooth", block: "start" });
  } catch (e) {
    toast("Could not load per-minute data", "error");
  }
}

// ‚îÄ‚îÄ Transcript context (KWIC) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function loadContext(episodeId) {
  const panel = document.getElementById("context-panel");
  const hitsEl = document.getElementById("context-hits");
  const titleEl = document.getElementById("context-title");
  panel.classList.remove("visible");
  hitsEl.innerHTML = "";
  try {
    const r = await fetch(`/api/context?keyword=${encodeURIComponent(currentKeyword)}&episode_id=${episodeId}`);
    const d = await r.json();
    if (!d.hits || d.hits.length === 0) return;

    titleEl.textContent = `Transcript mentions (${d.hits.length})`;
    hitsEl.innerHTML = d.hits.map(h => {
      const mm = String(h.minute).padStart(2, "0");
      const ss = String(h.second).padStart(2, "0");
      return `<div class="ctx-hit">
        <span class="ctx-ts">${mm}:${ss}</span>
        <span class="ctx-text">${escHtml(h.prefix)}<span class="ctx-match">${escHtml(h.match)}</span>${escHtml(h.suffix)}</span>
      </div>`;
    }).join("");
    panel.classList.add("visible");
  } catch (e) {
    // silently skip if context unavailable
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Helpers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function fmt(v) {
  if (v === null || v === undefined) return "‚Äî";
  return Number(v).toFixed(2);
}

function updateThreshold() {
  const input = document.getElementById("threshold-input");
  const result = document.getElementById("threshold-result");
  const n = parseInt(input.value, 10);
  if (!currentData || isNaN(n) || n < 1) { result.innerHTML = "‚Äî"; return; }

  const eps   = currentData.episodes;
  const total = eps.length;
  if (total === 0) { result.innerHTML = "‚Äî"; return; }

  // Use the merged episode count directly ‚Äî this is the same value shown in the table.
  // OR mode:  e.count = total combined mentions (adjacency-deduped across all keywords).
  // AND mode: e.count = total combined mentions in co-occurring episodes; 0 for others,
  //           so episodes where any keyword was absent are naturally excluded.
  const count = eps.filter(e => e.count >= n).length;

  const pct   = (count / total * 100).toFixed(1);
  const color = parseFloat(pct) >= 30 ? "var(--accent)" : parseFloat(pct) >= 10 ? "var(--gold)" : "var(--muted)";
  result.innerHTML =
    `<span style="color:${color}">${count} / ${total}</span>` +
    `<span class="t-frac">(${pct}%)</span>`;
}
document.getElementById("threshold-input").addEventListener("input", updateThreshold);

function escHtml(str) {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

function toast(msg, type) {
  const el = document.getElementById("toast");
  el.textContent = msg;
  el.className = `toast${type ? " " + type : ""}`;
  el.classList.add("show");
  clearTimeout(el._t);
  el._t = setTimeout(() => el.classList.remove("show"), 3200);
}
</script>
</body>
</html>
