<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Transcript Analyzer</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap');

:root {
  --bg:       #000000;
  --surface:  #111111;
  --card:     #111111;
  --border:   #2a2a2a;
  --accent:   #e6e6e6;
  --accent2:  #8a8a8a;
  --gold:     #e6e6e6;
  --green:    #8a8a8a;
  --danger:   #e6e6e6;
  --text:     #e6e6e6;
  --muted:    #8a8a8a;
  --radius:   0px;
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
input, select, textarea, button { font: inherit; }
html, body { height: 100%; }
body {
  font-family: 'VT323', 'Courier New', monospace;
  letter-spacing: 0;
  background:
    linear-gradient(180deg, rgba(230,230,230,.06) 0 1px, transparent 1px 100%),
    linear-gradient(90deg, rgba(230,230,230,.06) 0 1px, transparent 1px 100%),
    var(--bg);
  background-size: 18px 18px, 18px 18px, auto;
  color: var(--text);
  min-height: 100vh;
}

/* â”€â”€ Layout â”€â”€ */
.app { display: flex; flex-direction: column; min-height: 100vh; }

header {
  background: var(--card);
  border-bottom: 2px solid var(--border);
  box-shadow: none;
  padding: 16px 24px;
  display: flex;
  align-items: center;
  gap: 20px;
  flex-wrap: wrap;
}
.logo { font-size: .9rem; font-weight: 400; color: var(--accent); white-space: nowrap; text-shadow: none; font-family: 'Press Start 2P', cursive; }
.logo span { color: var(--text); }

.search-bar {
  display: flex;
  flex: 1;
  min-width: 260px;
  gap: 8px;
  align-items: center;
}
/* AND/OR mode toggle â€” only shown when 2+ keywords are present */
.mode-toggle {
  display: none;          /* hidden by default; JS sets display:flex */
  align-items: center;
  border: 2px solid #3f3f50;
  border-radius: var(--radius);
  overflow: hidden;
  flex-shrink: 0;
  font-size: .95rem;
  font-weight: 700;
  box-shadow: 0 0 12px rgba(155, 132, 255, 0.2);
}
.mode-toggle button {
  padding: 6px 12px;
  background: #181826;
  color: #9da3bd;
  border: none;
  cursor: pointer;
  transition: background .15s, color .15s, box-shadow .15s, transform .1s;
  line-height: 1;
  letter-spacing: .03em;
}
.mode-toggle button:hover {
  color: #d7dcff;
}
.mode-toggle button.active {
  background: linear-gradient(180deg, rgba(186,168,255,0.32), rgba(108,238,255,0.18));
  color: #f8f9ff;
  box-shadow: inset 0 0 0 1px rgba(206, 235, 255, 0.6), 0 0 14px rgba(151, 214, 255, 0.35);
  text-shadow: 0 0 8px rgba(194, 224, 255, 0.6);
}
.mode-toggle button:first-child {
  border-right: 1px solid #3f3f50;
}
.tag-input-wrap {
  flex: 1;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 5px;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 10px;
  cursor: text;
  transition: border-color .2s;
  min-height: 42px;
  box-shadow: inset 1px 1px 0 rgba(255,255,255,.12), inset -1px -1px 0 rgba(0,0,0,.75);
}
.tag-input-wrap:focus-within { border-color: var(--accent2); }
.tag-input-wrap input {
  flex: 1;
  min-width: 110px;
  background: transparent;
  border: none;
  color: var(--text);
  font-size: 1rem;
  outline: none;
  padding: 3px 4px;
}
.tag-input-wrap input::placeholder { color: var(--muted); }
.kw-tag {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  background: var(--surface);
  color: var(--text);
  border: 2px solid var(--border);
  border-radius: 0;
  padding: 2px 6px 2px 9px;
  font-size: .82rem;
  white-space: nowrap;
  user-select: none;
}
.kw-tag button {
  background: none;
  border: none;
  color: rgba(255,255,255,.7);
  cursor: pointer;
  font-size: 1rem;
  line-height: 1;
  padding: 0;
  margin-left: 1px;
}
.kw-tag button:hover { color: var(--text); }

.btn {
  padding: 10px 20px;
  border: 2px solid var(--border);
  border-radius: var(--radius);
  font-size: .8rem;
  font-weight: 400;
  font-family: 'Press Start 2P', cursive;
  cursor: pointer;
  transition: opacity .15s, transform .1s, filter .15s;
  text-transform: uppercase;
  box-shadow: none;
}
.btn:hover { filter: brightness(1.08); }
.btn:active { transform: translateY(2px); box-shadow: inset -2px -2px 0 rgba(255,255,255,.2), inset 2px 2px 0 rgba(0,0,0,.75); }
.btn:disabled { opacity: .4; cursor: default; }
.btn-primary   { background: var(--surface); color: var(--text); border-color: var(--border); }
.btn-secondary { background: var(--surface); color: var(--text); }
.btn-blue      { background: var(--surface); color: var(--text); border-color: var(--border); }
.btn-danger    { background: var(--surface); color: var(--text); border-color: var(--border); font-size: .8rem; padding: 5px 10px; }
.btn-sm        { padding: 6px 12px; font-size: .8rem; }

.header-actions { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }

.status-text { font-size: .85rem; color: var(--muted); }

/* â”€â”€ Main â”€â”€ */
.main-cols {
  display: flex;
  flex: 1;
  gap: 0;
  min-height: 0;
}

/* â”€â”€ Sidebar (episodes) â”€â”€ */
.sidebar {
  width: 320px;
  min-width: 280px;
  max-width: 380px;
  background: var(--card);
  border-right: 2px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  flex-shrink: 0;
  transition: width .2s ease, min-width .2s ease;
  position: relative;
}
.sidebar-rail-label {
  display: none;
  writing-mode: vertical-rl;
  transform: rotate(180deg);
  letter-spacing: .08em;
  font-size: .7rem;
  color: var(--accent2);
  text-transform: uppercase;
  padding: 12px 6px;
  user-select: none;
  cursor: default;
}
.mobile-sidebar-toggle {
  display: none;
  position: absolute;
  top: 12px;
  right: -30px;
  width: 30px;
  height: 34px;
  border: 1px solid var(--border);
  border-left: none;
  background: var(--surface);
  color: var(--accent2);
  font-size: 1rem;
  cursor: pointer;
}
.main-cols.sidebar-collapsed .sidebar {
  width: 28px;
  min-width: 28px;
}
.main-cols.sidebar-collapsed .sidebar-header,
.main-cols.sidebar-collapsed .select-all-row,
.main-cols.sidebar-collapsed .episode-count,
.main-cols.sidebar-collapsed .episode-list {
  display: none;
}
.main-cols.sidebar-collapsed .sidebar-rail-label {
  display: flex;
}
.sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.sidebar-title {
  font-size: .85rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .07em;
  color: var(--muted);
}
.sidebar-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.episode-count {
  font-size: .8rem;
  color: var(--muted);
  padding: 0 16px 10px;
}
.episode-list {
  overflow-y: auto;
  flex: 1;
  padding: 8px 0;
}
.ep-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  transition: background .1s;
}
.ep-item:hover { background: var(--surface); }
.ep-item input[type=checkbox] {
  accent-color: var(--accent2);
  width: 16px; height: 16px;
  flex-shrink: 0;
  cursor: pointer;
}
.ep-info { flex: 1; min-width: 0; }
.ep-title {
  font-size: .83rem;
  color: var(--text);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.ep-meta {
  font-size: .72rem;
  color: var(--muted);
  margin-top: 2px;
}
.ep-delete {
  opacity: 0;
  transition: opacity .15s;
  flex-shrink: 0;
}
.ep-item:hover .ep-delete { opacity: 1; }

.select-all-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border-bottom: 1px solid var(--border);
  font-size: .8rem;
  color: var(--muted);
}
.select-all-row input[type=checkbox] {
  accent-color: var(--accent2);
  width: 15px; height: 15px;
  cursor: pointer;
}

/* â”€â”€ Upload panel â”€â”€ */
/* â”€â”€ Help button â”€â”€ */
.btn-help {
  width: 32px; height: 32px;
  border-radius: 50%;
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--muted);
  font-size: .95rem;
  font-weight: 700;
  cursor: pointer;
  flex-shrink: 0;
  display: flex; align-items: center; justify-content: center;
  transition: border-color .15s, color .15s;
  line-height: 1;
}
.btn-help:hover { border-color: var(--accent2); color: var(--accent2); }

/* â”€â”€ Help modal â”€â”€ */
.help-panel {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.7);
  z-index: 100;
  align-items: center;
  justify-content: center;
}
.help-panel.visible { display: flex; }
.help-box {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 0;
  padding: 28px 32px;
  width: 600px;
  max-width: 96vw;
  max-height: 90vh;
  overflow-y: auto;
}
.help-box h2 {
  font-size: 1.1rem; font-weight: 700;
  margin-bottom: 20px; color: var(--text);
}
.help-box h3 {
  font-size: .78rem; font-weight: 700;
  text-transform: uppercase; letter-spacing: .07em;
  color: var(--muted); margin: 18px 0 8px;
}
.help-box h3:first-of-type { margin-top: 0; }
.help-box p  { font-size: .88rem; color: var(--text); line-height: 1.6; margin-bottom: 6px; }
.help-box ul { list-style: none; padding: 0; margin-bottom: 6px; }
.help-box ul li {
  font-size: .88rem; color: var(--text); line-height: 1.6;
  padding-left: 16px; position: relative;
}
.help-box ul li::before { content: "Â·"; position: absolute; left: 4px; color: var(--muted); }
.help-kv {
  display: grid; grid-template-columns: auto 1fr;
  gap: 4px 16px; margin-bottom: 6px;
}
.help-kv .k {
  font-family: 'Press Start 2P', monospace; font-size: .65rem;
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 4px; padding: 1px 7px;
  color: var(--accent2); white-space: nowrap; align-self: start;
}
.help-kv .v { font-size: .85rem; color: var(--text); line-height: 1.6; align-self: center; }
.help-divider { border: none; border-top: 1px solid var(--border); margin: 16px 0; }
.help-close-row { display: flex; justify-content: flex-end; margin-top: 22px; }

.upload-panel {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.7);
  z-index: 100;
  align-items: center;
  justify-content: center;
}
.upload-panel.visible { display: flex; }
.upload-box {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 0;
  padding: 28px;
  width: 520px;
  max-width: 96vw;
  max-height: 90vh;
  overflow-y: auto;
}
.upload-title {
  font-size: 1.1rem;
  font-weight: 700;
  margin-bottom: 18px;
  color: var(--text);
}
.upload-drop-zone {
  border: 2px dashed var(--border);
  border-radius: var(--radius);
  padding: 32px 20px;
  text-align: center;
  cursor: pointer;
  transition: border-color .2s, background .2s;
  margin-bottom: 16px;
}
.upload-drop-zone:hover,
.upload-drop-zone.drag-over {
  border-color: var(--accent2);
  background: rgba(230,230,230,.05);
}
.upload-drop-zone p { color: var(--muted); font-size: .9rem; }
.upload-drop-zone strong { color: var(--accent2); cursor: pointer; }
#file-input { display: none; }

/* Queued files list */
.queued-files { margin-bottom: 16px; }
.queued-file {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px 14px;
  margin-bottom: 8px;
}
.queued-file-name { font-size: .85rem; font-weight: 600; margin-bottom: 6px; }
.field-row {
  display: flex;
  gap: 8px;
  margin-bottom: 0;
}
.field-row input {
  flex: 1;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 6px 10px;
  color: var(--text);
  font-size: .82rem;
  outline: none;
}
.field-row input:focus { border-color: var(--accent2); }
.field-row input::placeholder { color: var(--muted); }
.field-row .date-input { flex: 0 0 130px; }

.upload-actions { display: flex; gap: 10px; justify-content: flex-end; }
.upload-progress { font-size: .85rem; color: var(--accent2); margin-top: 12px; }
.upload-result-item { font-size: .8rem; margin-top: 4px; }
.upload-result-item.ok    { color: var(--green); }
.upload-result-item.error { color: var(--accent); }

/* â”€â”€ Content area â”€â”€ */
.content {
  flex: 1;
  padding: 24px;
  overflow-y: auto;
  min-width: 0;
  background:
    linear-gradient(180deg, rgba(230,230,230,.04) 0 1px, transparent 1px 100%),
    var(--bg);
  background-size: 100% 10px, auto;
}

/* â”€â”€ Cards â”€â”€ */
.card {
  background: var(--card);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-bottom: 20px;
  box-shadow: none;
}
.card-title {
  font-size: .82rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .07em;
  color: var(--muted);
  margin-bottom: 16px;
}

/* â”€â”€ Stats row â”€â”€ */
.stats-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin-bottom: 20px; }
.stat-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 14px 16px;
  text-align: center;
}
.stat-val { font-size: 2rem; font-weight: 700; color: var(--accent); }
.stat-val.blue  { color: var(--accent2); }
.stat-val.gold  { color: var(--gold); }
.stat-val.green { color: var(--green); }
.stat-label { font-size: .75rem; color: var(--muted); margin-top: 4px; }

/* â”€â”€ Averages row â”€â”€ */
/* â”€â”€ Threshold checker â”€â”€ */
.threshold-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 20px;
  flex-wrap: wrap;
}
.threshold-label { font-size: .88rem; color: var(--muted); }
.threshold-input {
  width: 68px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  color: var(--text);
  font-size: .95rem;
  font-weight: 600;
  padding: 4px 8px;
  text-align: center;
  outline: none;
  transition: border-color .2s;
  /* hide browser spin buttons */
  -moz-appearance: textfield;
}
.threshold-input::-webkit-outer-spin-button,
.threshold-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
.threshold-input:focus { border-color: var(--accent2); }
.threshold-result {
  font-size: .97rem;
  font-weight: 700;
  color: var(--accent2);
  min-width: 120px;
}
.threshold-result .t-frac { color: var(--muted); font-weight: 400; font-size: .85rem; margin-left: 6px; }

#avgs-container { margin-bottom: 20px; }
.avgs-row { display: flex; gap: 10px; flex-wrap: wrap; }
.avg-kw-block { margin-bottom: 12px; }
.avg-kw-block:last-child { margin-bottom: 0; }
.avg-kw-label, .avg-row-label {
  font-size: .73rem; font-weight: 700; text-transform: uppercase;
  letter-spacing: .07em; color: var(--muted); margin-bottom: 5px;
}
.avg-pill {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 14px;
  font-size: .82rem;
  display: flex;
  flex-direction: column;
  gap: 1px;
  min-width: 88px;
}
.avg-pill .n  { color: var(--muted); font-size: .72rem; }
.avg-pill .v  { font-weight: 700; font-size: .97rem; }
.avg-pill .pm { color: var(--muted); font-size: .72rem; }
.avg-pill.ep1   .v { color: var(--text); }
.avg-pill.ep5   .v { color: var(--accent2); }
.avg-pill.ep20  .v { color: var(--text); }
.avg-pill.ep50  .v { color: var(--gold); }
.avg-pill.ep100 .v { color: var(--green); }

/* â”€â”€ Charts grid â”€â”€ */
.charts-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
@media (max-width: 900px) { .charts-grid { grid-template-columns: 1fr; } }
.chart-wrap { position: relative; height: 280px; }

/* â”€â”€ Table â”€â”€ */
.table-wrap { overflow-x: auto; }
table { width: 100%; border-collapse: collapse; font-size: .85rem; }
thead th {
  background: var(--surface);
  padding: 10px 12px;
  text-align: left;
  font-size: .75rem;
  text-transform: uppercase;
  letter-spacing: .06em;
  color: var(--text);
  border-bottom: 1px solid var(--border);
  white-space: nowrap;
}
tbody tr {
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  transition: background .1s;
}
tbody tr:hover { background: var(--surface); }
tbody tr.selected { background: rgba(230,230,230,.12); }
tbody td { padding: 9px 12px; }
.count-badge {
  display: inline-block;
  background: var(--surface);
  color: var(--text);
  border-radius: 0;
  border: 2px solid var(--border);
  padding: 1px 7px;
  font-weight: 700;
  font-size: .82rem;
  min-width: 24px;
  text-align: center;
}
.count-badge.zero { background: var(--border); color: var(--muted); }
.count-badge.dynamic {
  color: #e8f4ff;
}
.ep-num { color: var(--accent2); font-weight: 600; }
.per-min { color: var(--muted); font-size: .8rem; }

/* â”€â”€ Fair value table â”€â”€ */
.fv-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; }
.fv-cell {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  text-align: center;
  transition: border-color .15s, transform .1s;
  cursor: default;
}
.fv-cell:hover { border-color: var(--accent2); transform: translateY(-2px); }
.fv-n { font-size: .75rem; color: var(--muted); margin-bottom: 4px; }
.fv-pct { font-size: 1.5rem; font-weight: 700; color: var(--accent); }
.fv-pct.high   { color: var(--accent); }
.fv-pct.medium { color: var(--gold); }
.fv-pct.low    { color: var(--muted); }
.fv-label { font-size: .7rem; color: var(--muted); margin-top: 3px; }
.fv-model-badge {
  display: inline-block;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 0;
  padding: 3px 10px;
  font-size: .75rem;
  color: var(--accent2);
  margin-bottom: 14px;
}

/* â”€â”€ Per-minute panel â”€â”€ */
#minute-panel { display: none; }
#minute-panel.visible { display: block; }
#context-panel { display: none; }
#context-panel.visible { display: block; }
.ctx-hit {
  padding: 8px 0;
  border-bottom: 1px solid var(--border);
  font-size: .88rem;
  line-height: 1.55;
}
.ctx-hit:last-child { border-bottom: none; }
.ctx-ts {
  display: inline-block;
  min-width: 52px;
  color: var(--muted);
  font-size: .78rem;
  margin-right: 8px;
  flex-shrink: 0;
}
.ctx-text { color: var(--text); }
.ctx-match,
.kw-highlight {
  border-radius: 2px;
  padding: 0 3px;
  font-weight: 700;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.15);
}
.ep-title { line-height: 1.35; }

/* â”€â”€ Empty / loading states â”€â”€ */
.empty {
  text-align: center;
  padding: 60px 20px;
  color: var(--muted);
}
.spinner {
  width: 32px; height: 32px;
  border: 3px solid var(--border);
  border-top-color: var(--accent2);
  border-radius: 50%;
  animation: spin .7s linear infinite;
  margin: 0 auto 12px;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* â”€â”€ Lookback selector â”€â”€ */
.lookback-row { display: flex; align-items: center; gap: 10px; margin-bottom: 16px; flex-wrap: wrap; }
.lookback-row label { font-size: .82rem; color: var(--muted); }
.lookback-row select {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: 0;
  color: var(--text);
  padding: 5px 10px;
  font-size: .85rem;
  outline: none;
  cursor: pointer;
}

/* â”€â”€ Toast â”€â”€ */
.toast {
  position: fixed;
  bottom: 24px; right: 24px;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 12px 20px;
  font-size: .9rem;
  z-index: 200;
  transform: translateY(80px);
  opacity: 0;
  transition: all .3s;
  max-width: 320px;
}
.toast.show { transform: translateY(0); opacity: 1; }
.toast.success { border-color: var(--green); color: var(--green); }
.toast.error   { border-color: var(--accent); color: var(--accent); }

/* â”€â”€ Results visibility â”€â”€ */
#no-data-msg { display: none; }
#no-data-msg.visible { display: block; }
#results { display: none; }
#results.visible { display: block; }

/* â”€â”€ Responsive â”€â”€ */
@media (max-width: 720px) {
  header { padding: 12px; gap: 10px; }
  .logo { font-size: 1.1rem; }
  .search-bar { min-width: 100%; flex-wrap: wrap; gap: 6px; }
  .tag-input-wrap { min-height: 38px; padding: 4px 8px; }
  .btn { padding: 8px 12px; font-size: .82rem; }
  .mode-toggle { font-size: .72rem; }
  .mode-toggle button { padding: 5px 8px; }

  .main-cols { flex-direction: column; }
  .sidebar {
    display: none;
  }
  .mobile-sidebar-toggle { display: none !important; }
  .content { padding: 14px; }
  .card { padding: 14px; margin-bottom: 14px; }
  .stats-row { grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px; }
  .stat-card { padding: 10px; }
  .stat-val { font-size: 1.25rem; }
  .stat-label { font-size: .7rem; }

  .avgs-row { gap: 8px; }
  .avg-pill { flex: 1 1 calc(50% - 8px); min-width: 0; padding: 7px 10px; }
  .avg-pill .v { font-size: .9rem; }

  .threshold-row { gap: 6px; }
  .threshold-label { font-size: .8rem; }
  .threshold-input { width: 58px; font-size: .88rem; }
  .threshold-result { font-size: .88rem; min-width: 0; }

  .fv-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px; }
  .fv-cell { padding: 10px 8px; }
  .fv-pct { font-size: 1.2rem; }
  .fv-model-badge { display: inline-block; max-width: 100%; white-space: normal; }

  .table-wrap { font-size: .8rem; }
  tbody td { padding: 8px 8px; }
}
</style>
</head>
<body>
<div class="app">

<!-- â”€â”€ Header â”€â”€ -->
<header>
  <div class="logo">Transcript Analyzer</div>

  <div class="search-bar">
    <div class="tag-input-wrap" id="tag-wrap">
      <input type="text" id="search-input" placeholder="Add keywordâ€¦ e.g. million" autocomplete="off"/>
    </div>
    <div class="mode-toggle" id="mode-toggle" title="OR â€” sum mentions across keywords&#10;AND â€” only episodes where ALL keywords appear">
      <button id="mode-or"  class="active" onclick="setMode('or')">OR</button>
      <button id="mode-and" onclick="setMode('and')">AND</button>
    </div>
    <button class="btn btn-primary" id="search-btn">Search</button>
    <button class="btn-help" onclick="openHelp()" title="Search help">?</button>
  </div>

  <div class="header-actions">
    <span class="status-text" id="status-text">Loadingâ€¦</span>
  </div>
</header>

<!-- â”€â”€ Body â”€â”€ -->
<div class="main-cols">

  <!-- â”€â”€ Sidebar: Episodes â”€â”€ -->
  <aside class="sidebar" id="sidebar">
    <button class="mobile-sidebar-toggle" id="mobile-sidebar-toggle" aria-label="Toggle episodes sidebar"><span class="arr">â¯</span></button>
    <div class="sidebar-rail-label" id="sidebar-rail-label">Episodes</div>
    <div class="sidebar-header">
      <div class="sidebar-title">Episodes</div>
      <div class="sidebar-actions">
        <button class="btn btn-blue btn-sm" id="upload-btn">+ Upload</button>
        <button class="btn btn-secondary btn-sm" id="search-selected-btn">Search selected</button>
      </div>
    </div>

    <div class="select-all-row">
      <input type="checkbox" id="select-all-cb" title="Select / deselect all"/>
      <label for="select-all-cb" style="cursor:pointer">Select all</label>
      <span id="selected-count" style="margin-left:auto;color:var(--accent2)"></span>
    </div>

    <div class="episode-count" id="episode-count"></div>
    <div class="episode-list" id="episode-list">
      <div class="empty" style="padding:30px 20px">
        <p>No episodes yet.<br>Upload .txt transcripts to get started.</p>
      </div>
    </div>
  </aside>

  <!-- â”€â”€ Content â”€â”€ -->
  <main class="content">

    <!-- No data -->
    <div id="no-data-msg">
      <div class="empty">
        <h2 style="margin-bottom:10px">Upload transcripts to begin</h2>
        <p style="color:var(--muted)">Use desktop to upload .txt transcript files, then search for any keyword.</p>
      </div>
    </div>

    <!-- Results -->
    <div id="results">

      <!-- Stats row -->
      <div class="stats-row">
        <div class="stat-card">
          <div class="stat-val" id="stat-total">â€“</div>
          <div class="stat-label">Total mentions</div>
        </div>
        <div class="stat-card">
          <div class="stat-val blue" id="stat-episodes">â€“</div>
          <div class="stat-label">Episodes searched</div>
        </div>
        <div class="stat-card">
          <div class="stat-val gold" id="stat-avg1">â€“</div>
          <div class="stat-label">Avg last episode</div>
        </div>
        <div class="stat-card">
          <div class="stat-val green" id="stat-avg20">â€“</div>
          <div class="stat-label">Avg last 20 eps</div>
        </div>
      </div>

      <!-- Averages pills -->
      <div id="avgs-container"></div>

      <!-- Threshold checker -->
      <div class="threshold-row" id="threshold-row" style="display:none">
        <span class="threshold-label">Episodes with</span>
        <span class="threshold-label">â‰¥</span>
        <input type="number" id="threshold-input" class="threshold-input" min="1" step="1" placeholder="N">
        <span class="threshold-label" id="threshold-mode-label">mentions:</span>
        <span id="threshold-result" class="threshold-result">â€”</span>
      </div>

      <!-- Charts grid -->
      <div class="charts-grid">
        <div class="card">
          <div class="card-title" data-trend-title>Mentions per episode</div>
          <div class="chart-wrap"><canvas id="trend-chart"></canvas></div>
        </div>
        <div class="card">
          <div class="card-title" data-fv-chart>Polymarket fair value â€” next episode</div>
          <div class="lookback-row">
            <label>Lookback:</label>
            <select id="lookback-sel">
              <option value="5">Last 5</option>
              <option value="10">Last 10</option>
              <option value="20" selected>Last 20</option>
              <option value="50">Last 50</option>
              <option value="100">Last 100</option>
            </select>
            <span id="fv-model-badge" class="fv-model-badge"></span>
          </div>
          <div class="chart-wrap"><canvas id="fv-chart"></canvas></div>
        </div>
      </div>

      <!-- Fair value grid -->
      <div class="card">
        <div class="card-title" data-fv-grid>Fair value â€” P(â‰¥ N mentions) in next episode</div>
        <div class="fv-grid" id="fv-grid"></div>
      </div>

      <!-- Per-minute panel -->
      <div class="card" id="minute-panel">
        <div class="card-title" id="minute-title">Per-minute breakdown</div>
        <div class="chart-wrap" style="height:220px"><canvas id="minute-chart"></canvas></div>
      </div>

      <!-- Context / KWIC panel -->
      <div class="card" id="context-panel">
        <div class="card-title" id="context-title">Transcript mentions</div>
        <div id="context-hits"></div>
      </div>

      <!-- Episode table -->
      <div class="card">
        <div class="card-title">Episode history â€” click a row for per-minute breakdown &amp; transcript hits</div>
        <div class="table-wrap">
          <table id="ep-table">
            <thead>
              <tr>
                <th>Episode</th>
                <th>Date</th>
                <th>Mentions</th>
                <th>Per min</th>
                <th>Title</th>
              </tr>
            </thead>
            <tbody id="ep-tbody"></tbody>
          </table>
        </div>
      </div>

    </div><!-- /results -->
  </main>
</div><!-- /main-cols -->
</div><!-- /app -->

<!-- â”€â”€ Help modal â”€â”€ -->
<div class="help-panel" id="help-panel" onclick="if(event.target===this)closeHelp()">
  <div class="help-box">
    <h2>How search works</h2>

    <h3>Adding keywords</h3>
    <p>Type a word and press <strong>Enter</strong> or <strong>,</strong> to add it as a chip. Add multiple chips to search across keywords at once. Press <strong>Backspace</strong> to remove the last chip.</p>

    <h3>OR vs AND mode</h3>
    <div class="help-kv">
      <span class="k">OR</span><span class="v">Count every episode that mentions <em>any</em> keyword. Total = sum of all keyword occurrences.</span>
      <span class="k">AND</span><span class="v">Only count episodes where <em>every</em> keyword appears at least once.</span>
    </div>

    <hr class="help-divider">

    <h3>What counts as a match</h3>
    <div class="help-kv">
      <span class="k">Exact</span><span class="v">The word itself â€” <em>drug</em> matches "drug".</span>
      <span class="k">Plural</span><span class="v"><em>+s</em> or <em>+es</em> â€” "drugs", "asses" match their base terms. Verb conjugations like "collapses" do <strong>not</strong> count as a plural of "collapse".</span>
      <span class="k">Compound</span><span class="v">The term used as one component of a compound word. "killjoy" and "badass" count for "joy" and "ass". Derivational forms like "joyful" or "joyfully" do <strong>not</strong> count.</span>
    </div>

    <h3>Adjacent keywords count once</h3>
    <p>When two searched keywords appear next to each other in the transcript â€” e.g. searching <strong>Joe, Biden</strong> and the transcript says "Joe Biden" â€” that adjacent pair counts as <strong>one</strong> mention, not two. Non-adjacent occurrences each count separately.</p>

    <h3>What's excluded</h3>
    <ul>
      <li>The standard intro marker line and all text before it are ignored.</li>
      <li>Words embedded inside unrelated longer words are filtered out â€” e.g. "parliament" does not count for "amen", "embarrassing" does not count for "ass".</li>
      <li>Number words (thirteen â€“ nineteen) do not count for "teen".</li>
    </ul>

    <h3>Phrases</h3>
    <p>Type a multi-word phrase as a single chip (e.g. <em>prime minister</em>) to search for that exact sequence of words.</p>

    <div class="help-close-row">
      <button class="btn btn-secondary" onclick="closeHelp()">Close</button>
    </div>
  </div>
</div>

<!-- â”€â”€ Upload panel â”€â”€ -->
<div class="upload-panel" id="upload-panel">
  <div class="upload-box">
    <div class="upload-title">Upload Transcripts</div>

    <div class="upload-drop-zone" id="drop-zone">
      <p>Drag &amp; drop .txt files here<br>or <strong id="browse-link">browse</strong></p>
      <input type="file" id="file-input" accept=".txt" multiple/>
    </div>

    <div class="queued-files" id="queued-files"></div>

    <div class="upload-actions">
      <button class="btn btn-secondary" id="upload-cancel-btn">Cancel</button>
      <button class="btn btn-primary" id="upload-submit-btn" disabled>Upload</button>
    </div>

    <div id="upload-progress" class="upload-progress" style="display:none"></div>
    <div id="upload-results"></div>
  </div>
</div>

<!-- â”€â”€ Toast â”€â”€ -->
<div class="toast" id="toast"></div>

<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// State
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let allEpisodes   = [];   // [{id, title, episode_date, ...}]
let selectedIds   = new Set();  // episode IDs checked in sidebar
let currentData   = null;
let currentKeyword = "";
let currentKeywordStyles = {};

// Neon palette for keyword-linked visuals.
const NEON_BASE_COLORS = [
  "#00f5ff", // cyan
  "#ff2bd6", // hot magenta
  "#7bff00", // neon lime
  "#ff9f1c", // electric orange
  "#8b5cf6", // violet
  "#ffe600", // laser yellow
  "#00ff85", // mint green
  "#ff4d6d", // neon rose
  "#39a0ff", // bright blue
  "#c2ff00", // acid lime
];

function hexToRgb(hex) {
  const v = hex.replace("#", "");
  if (v.length !== 6) return { r: 230, g: 230, b: 230 };
  return {
    r: parseInt(v.slice(0, 2), 16),
    g: parseInt(v.slice(2, 4), 16),
    b: parseInt(v.slice(4, 6), 16),
  };
}

function withAlpha(hex, alpha) {
  const { r, g, b } = hexToRgb(hex);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function lightenHex(hex, amount = 0.2) {
  const { r, g, b } = hexToRgb(hex);
  const mix = c => Math.max(0, Math.min(255, Math.round(c + (255 - c) * amount)));
  const toHex = c => c.toString(16).padStart(2, "0");
  return `#${toHex(mix(r))}${toHex(mix(g))}${toHex(mix(b))}`;
}

function rgbToHsl(r, g, b) {
  const rn = r / 255;
  const gn = g / 255;
  const bn = b / 255;
  const max = Math.max(rn, gn, bn);
  const min = Math.min(rn, gn, bn);
  let h = 0;
  let s = 0;
  const l = (max + min) / 2;

  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case rn:
        h = (gn - bn) / d + (gn < bn ? 6 : 0);
        break;
      case gn:
        h = (bn - rn) / d + 2;
        break;
      default:
        h = (rn - gn) / d + 4;
        break;
    }
    h /= 6;
  }

  return {
    h: Math.round(h * 360),
    s: Math.round(s * 100),
    l: Math.round(l * 100),
  };
}

function getKeywordColor(keyword, index = 0) {
  const term = String(keyword || "").toLowerCase();
  const seed = [...term].reduce((sum, ch) => sum + ch.charCodeAt(0), 0) + (index * 17);
  return NEON_BASE_COLORS[seed % NEON_BASE_COLORS.length];
}

function buildKeywordStyle(keyword, index = 0) {
  const base = getKeywordColor(keyword, index);
  const line = lightenHex(base, 0.25);
  return {
    base,
    line,
    barBg: withAlpha(base, 0.78),
    hitBg: withAlpha(base, 0.2),
    glow: withAlpha(base, 0.55),
  };
}

function buildKeywordStyles(perKeyword = []) {
  const styles = {};
  (perKeyword || []).forEach((kw, idx) => {
    styles[kw.keyword.toLowerCase()] = buildKeywordStyle(kw.keyword, idx);
  });
  return styles;
}

function getStyleForKeyword(keyword, kwStyles = {}, fallbackIndex = 0) {
  const k = String(keyword || "").toLowerCase();
  return kwStyles[k] || buildKeywordStyle(keyword, fallbackIndex);
}

Chart.defaults.font.family = "'Press Start 2P', 'VT323', monospace";
Chart.defaults.color = "#8a8a8a";
let trendChart    = null;
let fvChart       = null;
let minuteChart   = null;
let queuedFiles   = [];   // [{file, title, date}]
let desktopSidebarCollapsed = false;
const MOBILE_MEDIA_QUERY = "(max-width: 720px)";

function isMobileView() {
  return window.matchMedia(MOBILE_MEDIA_QUERY).matches;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Boot
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener("DOMContentLoaded", () => {
  loadEpisodes();

  document.getElementById("search-btn").addEventListener("click", doSearch);

  // Tag-chip input: Enter/comma adds a chip; Backspace removes last chip
  document.getElementById("tag-wrap").addEventListener("click", () =>
    document.getElementById("search-input").focus()
  );
  document.getElementById("search-input").addEventListener("keydown", e => {
    const inp = e.target;
    if (e.key === "Enter") {
      if (inp.value.trim()) { addKwTag(inp.value); }
      else { doSearch(); }
    } else if (e.key === ",") {
      e.preventDefault();
      addKwTag(inp.value);
    } else if (e.key === "Backspace" && inp.value === "") {
      const chips = document.querySelectorAll(".kw-tag");
      if (chips.length) chips[chips.length - 1].remove();
      updateSearchPlaceholder();
    }
  });
  document.getElementById("search-input").addEventListener("input", updateModeToggleVisibility);
  document.getElementById("lookback-sel").addEventListener("change", () => {
    if (currentKeyword) doSearch();
  });

  // Sidebar
  document.getElementById("upload-btn").addEventListener("click", openUpload);
  document.getElementById("search-selected-btn").addEventListener("click", doSearch);
  document.getElementById("select-all-cb").addEventListener("change", toggleSelectAll);
  initSidebarBehavior();

  // Upload panel
  document.getElementById("upload-cancel-btn").addEventListener("click", closeUpload);
  document.getElementById("upload-submit-btn").addEventListener("click", submitUpload);
  document.getElementById("browse-link").addEventListener("click", () =>
    document.getElementById("file-input").click()
  );
  document.getElementById("drop-zone").addEventListener("click", e => {
    if (e.target.id !== "browse-link") document.getElementById("file-input").click();
  });
  document.getElementById("file-input").addEventListener("change", e =>
    addFiles(Array.from(e.target.files))
  );

  // Drag-and-drop
  const dz = document.getElementById("drop-zone");
  dz.addEventListener("dragover", e => { e.preventDefault(); dz.classList.add("drag-over"); });
  dz.addEventListener("dragleave", () => dz.classList.remove("drag-over"));
  dz.addEventListener("drop", e => {
    e.preventDefault();
    dz.classList.remove("drag-over");
    addFiles(Array.from(e.dataTransfer.files).filter(f => /\.txt$/i.test(f.name)));
  });
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Load episodes from server
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadEpisodes() {
  try {
    const r = await fetch("/api/episodes");
    allEpisodes = await r.json();
    // Default: all selected
    selectedIds = new Set(allEpisodes.map(e => e.id));
    renderSidebar();
    updateStatus();
  } catch {
    document.getElementById("status-text").textContent = "Server unreachable";
  }
}

function updateStatus() {
  const total = allEpisodes.length;
  document.getElementById("status-text").textContent =
    total === 0 ? "No episodes uploaded" : `${total} episode${total !== 1 ? "s" : ""} in database`;

  if (total === 0) {
    document.getElementById("no-data-msg").classList.add("visible");
    document.getElementById("results").classList.remove("visible");
  }
}


function initSidebarBehavior() {
  const cols = document.querySelector(".main-cols");
  const sidebar = document.getElementById("sidebar");
  const mobileToggle = document.getElementById("mobile-sidebar-toggle");

  const applySidebarMode = () => {
    if (isMobileView()) {
      cols.classList.remove("sidebar-collapsed");
      cols.classList.remove("mobile-sidebar-open");
      desktopSidebarCollapsed = false;
      return;
    }
    desktopSidebarCollapsed = true;
    cols.classList.add("sidebar-collapsed");
    cols.classList.remove("mobile-sidebar-open");
  };

  applySidebarMode();
  window.addEventListener("resize", applySidebarMode);

  sidebar.addEventListener("mouseenter", () => {
    if (isMobileView()) return;
    cols.classList.remove("sidebar-collapsed");
  });
  sidebar.addEventListener("mouseleave", () => {
    if (isMobileView()) return;
    if (desktopSidebarCollapsed) cols.classList.add("sidebar-collapsed");
  });
  sidebar.addEventListener("wheel", () => {
    if (isMobileView()) return;
    cols.classList.remove("sidebar-collapsed");
  }, { passive: true });

  mobileToggle.addEventListener("click", () => {
    if (isMobileView()) return;
    cols.classList.toggle("mobile-sidebar-open");
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Sidebar
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSidebar() {
  const list = document.getElementById("episode-list");
  const countEl = document.getElementById("episode-count");

  if (allEpisodes.length === 0) {
    list.innerHTML = `<div class="empty" style="padding:30px 20px">
      <p>No episodes yet.<br>Upload .txt transcripts to get started.</p>
    </div>`;
    countEl.textContent = "";
    document.getElementById("selected-count").textContent = "";
    return;
  }

  countEl.textContent = `${allEpisodes.length} episode${allEpisodes.length !== 1 ? "s" : ""}`;
  updateSelectedCount();

  list.innerHTML = allEpisodes.map(ep => {
    const checked = selectedIds.has(ep.id) ? "checked" : "";
    const num = ep.episode_number ? `#${ep.episode_number} Â· ` : "";
    const date = ep.episode_date || ep.uploaded_at?.slice(0, 10) || "";
    const dur  = ep.duration_seconds > 0 ? ` Â· ${Math.round(ep.duration_seconds / 60)}m` : "";
    const title = (ep.title || "").slice(0, 45) + ((ep.title || "").length > 45 ? "â€¦" : "");
    return `<div class="ep-item" data-id="${ep.id}">
      <input type="checkbox" ${checked} data-id="${ep.id}" onclick="toggleEpisode(event,${ep.id})"/>
      <div class="ep-info">
        <div class="ep-title">${escHtml(title)}</div>
        <div class="ep-meta">${num}${date}${dur}</div>
      </div>
      <button class="btn btn-danger ep-delete" onclick="deleteEpisode(event,${ep.id})" title="Delete">âœ•</button>
    </div>`;
  }).join("");

  // Sync select-all checkbox
  const allChecked = allEpisodes.every(e => selectedIds.has(e.id));
  const noneChecked = allEpisodes.every(e => !selectedIds.has(e.id));
  const cb = document.getElementById("select-all-cb");
  cb.checked = allChecked;
  cb.indeterminate = !allChecked && !noneChecked;
}

function toggleEpisode(event, id) {
  event.stopPropagation();
  if (selectedIds.has(id)) {
    selectedIds.delete(id);
  } else {
    selectedIds.add(id);
  }
  updateSelectedCount();
  // Sync select-all checkbox
  const allChecked = allEpisodes.every(e => selectedIds.has(e.id));
  const noneChecked = allEpisodes.every(e => !selectedIds.has(e.id));
  const cb = document.getElementById("select-all-cb");
  cb.checked = allChecked;
  cb.indeterminate = !allChecked && !noneChecked;
}

function toggleSelectAll() {
  const cb = document.getElementById("select-all-cb");
  if (cb.checked) {
    selectedIds = new Set(allEpisodes.map(e => e.id));
  } else {
    selectedIds = new Set();
  }
  renderSidebar();
}

function updateSelectedCount() {
  const n = selectedIds.size;
  const total = allEpisodes.length;
  document.getElementById("selected-count").textContent =
    n === total ? "" : `${n} selected`;
}

async function deleteEpisode(event, id) {
  event.stopPropagation();
  if (!confirm("Delete this episode and all its data?")) return;
  try {
    const r = await fetch(`/api/episode/${id}`, { method: "DELETE" });
    if (!r.ok) throw new Error("Delete failed");
    allEpisodes = allEpisodes.filter(e => e.id !== id);
    selectedIds.delete(id);
    renderSidebar();
    updateStatus();
    toast("Episode deleted", "success");
  } catch (e) {
    toast(e.message, "error");
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Upload panel
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openUpload() {
  if (isMobileView()) {
    toast("Uploads are only available on desktop.", "error");
    return;
  }
  queuedFiles = [];
  document.getElementById("queued-files").innerHTML = "";
  document.getElementById("upload-submit-btn").disabled = true;
  document.getElementById("file-input").value = "";
  document.getElementById("upload-progress").style.display = "none";
  document.getElementById("upload-results").innerHTML = "";
  document.getElementById("upload-panel").classList.add("visible");
}

function closeUpload() {
  document.getElementById("upload-panel").classList.remove("visible");
}

function openHelp()  { document.getElementById("help-panel").classList.add("visible"); }
function closeHelp() { document.getElementById("help-panel").classList.remove("visible"); }
document.addEventListener("keydown", e => { if (e.key === "Escape") closeHelp(); });

function addFiles(files) {
  files.forEach(f => {
    if (!/\.txt$/i.test(f.name)) return;
    queuedFiles.push({ file: f, title: "" });
  });
  renderQueuedFiles();
  document.getElementById("upload-submit-btn").disabled = queuedFiles.length === 0;
}

function renderQueuedFiles() {
  const container = document.getElementById("queued-files");
  if (queuedFiles.length === 0) {
    container.innerHTML = "";
    return;
  }
  container.innerHTML = queuedFiles.map((item, i) => `
    <div class="queued-file" data-index="${i}">
      <div class="queued-file-name">ğŸ“„ ${escHtml(item.file.name)}</div>
      <div class="field-row">
        <input type="text"
               placeholder="Episode title (optional)"
               value="${escHtml(item.title)}"
               oninput="queuedFiles[${i}].title=this.value"/>
      </div>
    </div>
  `).join("");
}

async function submitUpload() {
  if (queuedFiles.length === 0) return;

  const btn = document.getElementById("upload-submit-btn");
  const prog = document.getElementById("upload-progress");
  const resultsEl = document.getElementById("upload-results");

  btn.disabled = true;
  prog.style.display = "block";
  prog.textContent = `Uploading ${queuedFiles.length} file(s)â€¦`;
  resultsEl.innerHTML = "";

  const fd = new FormData();
  queuedFiles.forEach(item => {
    fd.append("files[]", item.file, item.file.name);
    fd.append("title[]", item.title || item.file.name.replace(/\.txt$/i, ""));
  });

  try {
    const r = await fetch("/api/upload", { method: "POST", body: fd });
    const data = await r.json();

    let html = "";
    (data.created || []).forEach(ep => {
      html += `<div class="upload-result-item ok">âœ“ ${escHtml(ep.title)} â€” ${ep.segment_count} segments</div>`;
    });
    (data.errors || []).forEach(err => {
      html += `<div class="upload-result-item error">âœ— ${escHtml(err.filename)}: ${escHtml(err.error)}</div>`;
    });
    resultsEl.innerHTML = html;

    prog.textContent = `Done. ${(data.created||[]).length} uploaded, ${(data.errors||[]).length} errors.`;

    if ((data.created || []).length > 0) {
      await loadEpisodes();
      toast(`${data.created.length} episode(s) uploaded`, "success");
    }

    queuedFiles = [];
    btn.disabled = true;
  } catch (e) {
    prog.textContent = "Upload failed: " + e.message;
    toast("Upload failed", "error");
    btn.disabled = false;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ Tag-chip keyword helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€ AND / OR mode toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let searchMode = "or";   // "or" | "and"

function setMode(m) {
  searchMode = m;
  document.getElementById("mode-or").classList.toggle("active",  m === "or");
  document.getElementById("mode-and").classList.toggle("active", m === "and");
}

function updateModeToggleVisibility() {
  const chips = document.querySelectorAll(".kw-tag").length;
  const cur   = document.getElementById("search-input").value.trim();
  // Show when â‰¥2 keywords are present (chips + possibly one in the input box)
  const total = chips + (cur ? 1 : 0);
  document.getElementById("mode-toggle").style.display = total >= 2 ? "flex" : "none";
}

function updateSearchPlaceholder() {
  const inp = document.getElementById("search-input");
  const hasChips = document.querySelectorAll(".kw-tag").length > 0;
  inp.placeholder = hasChips ? "Add another keywordâ€¦" : "Add keywordâ€¦ e.g. million";
  updateModeToggleVisibility();
}

function addKwTag(raw) {
  // Split only on commas â€” spaces are kept so phrases like "prime minister" stay intact.
  const terms = raw.split(/,+/).map(t => t.trim()).filter(Boolean);
  if (!terms.length) return;
  const existing = () => [...document.querySelectorAll(".kw-tag")].map(el => el.dataset.kw.toLowerCase());
  const inp = document.getElementById("search-input");
  const wrap = document.getElementById("tag-wrap");
  terms.forEach(kw => {
    if (existing().includes(kw.toLowerCase())) return;
    const chip = document.createElement("span");
    chip.className = "kw-tag";
    chip.dataset.kw = kw;
    const kwStyle = buildKeywordStyle(kw, existing().length);
    chip.style.borderColor = kwStyle.base;
    chip.style.boxShadow = `0 0 10px ${kwStyle.glow}`;
    chip.innerHTML = `<span style="color:${kwStyle.line}">${escHtml(kw)}</span> <button aria-label="remove">Ã—</button>`;
    chip.querySelector("button").addEventListener("click", () => {
      chip.remove();
      updateSearchPlaceholder();
    });
    wrap.insertBefore(chip, inp);
  });
  inp.value = "";
  updateSearchPlaceholder();
}

function getKeywords() {
  const chips = [...document.querySelectorAll(".kw-tag")].map(el => el.dataset.kw);
  const cur = document.getElementById("search-input").value.trim().replace(/,+$/, "").trim();
  if (cur) chips.push(cur);
  return chips.filter(Boolean);
}

// Search
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function doSearch() {
  const keywords = getKeywords();
  if (!keywords.length) { toast("Enter at least one keyword", "error"); return; }
  if (allEpisodes.length === 0) { toast("Upload transcripts first", "error"); return; }

  const kw = keywords.join(", ");
  const lookback = document.getElementById("lookback-sel").value;
  currentKeyword = kw;

  // Determine episode filter
  const allSelected = selectedIds.size === allEpisodes.length;
  const episodeIdsParam = allSelected
    ? ""
    : Array.from(selectedIds).join(",");

  if (selectedIds.size === 0) { toast("Select at least one episode", "error"); return; }

  const btn = document.getElementById("search-btn");
  btn.disabled = true;
  btn.textContent = "Searchingâ€¦";

  try {
    const multi = keywords.length > 1;
    const mode  = multi ? searchMode : "or";
    let url = `/api/search?keyword=${encodeURIComponent(kw)}&lookback=${lookback}&mode=${mode}`;
    if (episodeIdsParam) url += `&episode_ids=${episodeIdsParam}`;

    const r = await fetch(url);
    if (!r.ok) { const e = await r.json(); throw new Error(e.error || r.statusText); }
    const data = await r.json();
    currentData = data;
    renderResults(data);
    document.getElementById("results").classList.add("visible");
    document.getElementById("no-data-msg").classList.remove("visible");
  } catch (e) {
    toast(e.message, "error");
  } finally {
    btn.disabled = false;
    btn.textContent = "Search";
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Render
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderResults(data) {
  const eps  = data.episodes;
  const avgs = data.averages;
  const fv   = data.fair_value;

  const isAnd = data.mode === "and" && (data.per_keyword || []).length > 1;
  const isMultiOr = data.mode !== "and" && (data.per_keyword || []).length > 1;
  currentKeywordStyles = buildKeywordStyles(data.per_keyword || []);

  // In multi-keyword OR mode, aggregate cards/pills should use the same
  // adjacent-deduped merged count shown in the episode table.
  let displayAverages = avgs;
  let displayAveragesPerMin = data.averages_per_min;

  const total = eps.reduce((s, e) => s + e.count, 0);
  document.getElementById("stat-total").textContent    = total;
  document.getElementById("stat-episodes").textContent = eps.length;
  document.getElementById("stat-avg1").textContent     = fmt(displayAverages.last_1);
  document.getElementById("stat-avg20").textContent    = fmt(displayAverages.last_20);

  // Average pills

  const fmtPm = v => (v !== null && v !== undefined) ? `${Number(v).toFixed(3)}/min` : "â€”";
  const makePills = (a, apm, style = null) => {
    const defs = [
      {cls:"ep1",   n:"Last 1",   v: a.last_1,   pm: apm.last_1},
      {cls:"ep5",   n:"Last 5",   v: a.last_5,   pm: apm.last_5},
      {cls:"ep20",  n:"Last 20",  v: a.last_20,  pm: apm.last_20},
      {cls:"ep50",  n:"Last 50",  v: a.last_50,  pm: apm.last_50},
      {cls:"ep100", n:"Last 100", v: a.last_100, pm: apm.last_100},
    ];
    const pillStyle = style
      ? ` style="border-color:${style.base};box-shadow:0 0 8px ${style.glow};"`
      : "";
    const valueStyle = style
      ? ` style="color:${style.line};text-shadow:0 0 8px ${style.glow};"`
      : "";
    return defs.map(p =>
      `<div class="avg-pill ${p.cls}"${pillStyle}>
         <span class="n">${p.n}</span>
         <span class="v"${valueStyle}>${fmt(p.v)}</span>
         <span class="pm">${fmtPm(p.pm)}</span>
       </div>`
    ).join("");
  };

  let avgsHtml;
  if (isMultiOr) {
    // OR multi-keyword: show adjacent-deduped combined total + one row per keyword.
    const combinedBlock =
      `<div class="avg-kw-block">
         <div class="avg-kw-label">Combined (adjacency-deduped)</div>
         <div class="avgs-row">${makePills(displayAverages, displayAveragesPerMin)}</div>
       </div>`;
    avgsHtml = combinedBlock + (data.per_keyword || []).map(kw =>
      (() => {
         const style = getStyleForKeyword(kw.keyword, currentKeywordStyles);
         return `<div class="avg-kw-block">
           <div class="avg-kw-label" style="color:${style.line}; text-shadow:0 0 8px ${style.glow};">${escHtml(kw.keyword)}</div>
           <div class="avgs-row">${makePills(kw.averages, kw.averages_per_min, style)}</div>
         </div>`;
      })()
    ).join("");
  } else {
    // Single keyword or AND mode: one row (labelled for AND)
    const label = isAnd ? `<div class="avg-row-label">Co-occurrence average</div>` : "";
    const singleStyle = isAnd
      ? { base: "#22d3ee", line: "#9cf7ff", glow: withAlpha("#22d3ee", 0.55) }
      : getStyleForKeyword((data.per_keyword && data.per_keyword[0] ? data.per_keyword[0].keyword : currentKeyword || "Mentions"), currentKeywordStyles, 0);
    avgsHtml = `${label}<div class="avgs-row">${makePills(avgs, data.averages_per_min, singleStyle)}</div>`;
  }
  document.getElementById("avgs-container").innerHTML = avgsHtml;

  // Threshold checker
  document.getElementById("threshold-row").style.display = "flex";
  document.getElementById("threshold-input").value = "";
  document.getElementById("threshold-result").innerHTML = "â€”";
  document.getElementById("threshold-mode-label").textContent =
    isAnd     ? "combined co-occurrence mentions:"
    : isMultiOr ? "combined mentions:"
    : "mentions:";

  // Set of episode IDs where co-occurrence happened (AND mode only)
  const coOccurIds = isAnd
    ? new Set(data.episodes.filter(e => e.count > 0).map(e => e.episode_id))
    : null;

  renderTrendChart(eps, data.per_keyword, isAnd, coOccurIds, currentKeywordStyles);

  const modelLabel = {
    "poisson":       "Poisson",
    "empirical":     "Empirical",
    "neg-binomial":  "Neg-Binomial",
    "zero-inflated": "Zero-Inflated NB",
  }[fv.model] || fv.model;
  const piSuffix = (fv.model === "zero-inflated" && fv.pi_estimate != null)
    ? `  Ï€=${(fv.pi_estimate * 100).toFixed(0)}%`
    : "";
  document.getElementById("fv-model-badge").textContent = modelLabel + piSuffix;

  // Update all card titles to reflect AND co-occurrence mode
  document.querySelector(".card-title[data-trend-title]").textContent =
    isAnd ? "Co-occurrence mentions per episode" : "Mentions per episode";
  document.querySelector(".card-title[data-fv-chart]").textContent =
    isAnd ? "Polymarket fair value â€” co-occurrence next episode" : "Polymarket fair value â€” next episode";
  document.querySelector(".card-title[data-fv-grid]").textContent =
    isAnd ? "Fair value â€” P(both words in â‰¥ N mentions) next episode" : "Fair value â€” P(â‰¥ N mentions) in next episode";

  // In AND mode show the single merged FV bar (co-occurrence FV);
  // in OR mode show per-keyword grouped bars.
  renderFVChart(fv, isAnd ? null : data.per_keyword_fv, currentKeywordStyles);
  renderFVGrid(fv);
  renderTable(eps, currentKeywordStyles);

  document.getElementById("minute-panel").classList.remove("visible");
  if (minuteChart) { minuteChart.destroy(); minuteChart = null; }
}

// â”€â”€ Trend chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTrendChart(episodes, perKeyword, isAnd, coOccurIds, kwStyles = {}) {
  const ctx = document.getElementById("trend-chart").getContext("2d");
  if (trendChart) trendChart.destroy();

  const eps    = [...episodes].reverse();
  const labels = eps.map(e => e.episode_number ? `#${e.episode_number}` : (e.episode_date || `ID${e.episode_id}`));
  const mergedCounts = eps.map(e => e.count);
  const isMultiKeyword = perKeyword && perKeyword.length > 1;
  // For multi-keyword queries, stack per-keyword bars in both OR and AND
  // modes so the histogram shows each keyword's contribution by color.
  const stacked = !!isMultiKeyword;


  let barDatasets;
  if (isMultiKeyword) {
    barDatasets = perKeyword.map((kw, i) => {
      const style = getStyleForKeyword(kw.keyword, kwStyles, i);
      const idxMap = Object.fromEntries(kw.episodes.map(e => [e.episode_id, e.count]));
      const counts = eps.map(e =>
        (isAnd && coOccurIds && !coOccurIds.has(e.episode_id)) ? 0 : (idxMap[e.episode_id] ?? 0)
      );
      return {
        label: kw.keyword,
        data: counts,
        backgroundColor: style.barBg,
        borderColor: style.base,
        borderWidth: 1,
        borderRadius: 3,
        grouped: false,
        type: "bar",
        order: 2,
        stack: stacked ? "kw" : undefined,
      };
    });
  } else {
    const singleKeyword = perKeyword && perKeyword.length === 1 ? perKeyword[0].keyword : "Mentions";
    const style = getStyleForKeyword(singleKeyword, kwStyles, 0);
    const label = singleKeyword;
    barDatasets = [{
      label, data: mergedCounts,
      backgroundColor: mergedCounts.map(c => c > 0 ? style.barBg : "#2a2a2a"),
      borderColor:     mergedCounts.map(c => c > 0 ? style.base : "#2a2a2a"),
      borderWidth: 1, borderRadius: 3, type: "bar", order: 2,
    }];
  }

  // Keep the rolling line adjacency-deduped so multi-keyword adjacent phrases
  // (e.g. "Bill Clinton") are counted once in calculations.
  const rollingSourceCounts = mergedCounts;

  const rolling20 = rollingSourceCounts.map((_, i) => {
    const start = Math.max(0, i - 19);
    const window = rollingSourceCounts.slice(start, i + 1);
    return window.reduce((a, b) => a + b, 0) / window.length;
  });

  const lineDatasets = isMultiKeyword
    ? perKeyword.map((kw, i) => {
        const style = getStyleForKeyword(kw.keyword, kwStyles, i);
        const idxMap = Object.fromEntries(kw.episodes.map(e => [e.episode_id, e.count]));
        const counts = eps.map(e => (isAnd && coOccurIds && !coOccurIds.has(e.episode_id)) ? 0 : (idxMap[e.episode_id] ?? 0));
        const rolling = counts.map((_, idx) => {
          const start = Math.max(0, idx - 19);
          const window = counts.slice(start, idx + 1);
          return window.reduce((a, b) => a + b, 0) / window.length;
        });
        return {
          label: `${kw.keyword} rolling`,
          data: rolling,
          type: "line",
          borderColor: style.line,
          backgroundColor: style.line,
          borderWidth: 1.8,
          borderDash: [5, 3],
          pointRadius: 0,
          tension: 0.24,
          order: 10,
        };
      })
    : [{
        label: "Rolling avg (20 eps)",
        data: rolling20,
        type: "line",
        borderColor: "#9cf7ff",
        backgroundColor: "#9cf7ff",
        borderWidth: 2,
        pointRadius: 0,
        tension: 0.25,
        // Keep the rolling-average line above bars so it is always visible.
        order: 10,
      }];


  trendChart = new Chart(ctx, {
    data: { labels, datasets: [...barDatasets, ...lineDatasets] },
    options: {
      responsive: true, maintainAspectRatio: false,
      animation: { duration: 300 },
      plugins: {
        legend: { labels: { color: "#8a8a8a", font: { size: 11 }, boxWidth: 18, padding: 10 }, position: "top" },
        tooltip: {
          callbacks: {
            title: items => { const i = items[0].dataIndex; return eps[i].title?.slice(0,50) || labels[i]; },
            label: item => `${item.dataset.label}: ${Number(item.raw).toFixed(2)}`,
          }
        }
      },
      scales: {
        x: { ticks: { color: "#8a8a8a", maxRotation: 45, font: { size: 10 }, maxTicksLimit: 25 }, grid: { display: false }, stacked },
        y: { ticks: { color: "#8a8a8a" }, grid: { display: false }, beginAtZero: true, stacked }
      }
    }
  });
}

// â”€â”€ Fair-value chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderFVChart(fv, pkFv, kwStyles = {}) {
  const ctx = document.getElementById("fv-chart").getContext("2d");
  if (fvChart) fvChart.destroy();

  const labels   = fv.buckets.map(b => b.label);
  const multiKw  = pkFv && pkFv.length > 1;

  // AND mode (pkFv===null): single merged co-occurrence bar in a distinct teal colour.
  // OR multi-kw mode: one grouped bar per keyword.
  // Single keyword: single bar.
  const isAndMode = pkFv === null;
  const AND_STYLE = { base: "#22d3ee", barBg: withAlpha("#22d3ee", 0.78) };

  const datasets = multiKw
    ? pkFv.map((kw, i) => {
        const style = getStyleForKeyword(kw.keyword, kwStyles, i);
        return {
          label: kw.keyword,
          data: kw.buckets.map(b => b.pct),
          backgroundColor: style.barBg,
          borderColor: style.base,
          borderWidth: 1, borderRadius: 3,
        };
      })
    : [{
        label: isAndMode ? "co-occurrence" : (pkFv && pkFv.length === 1 ? pkFv[0].keyword : "P(â‰¥ N) %"),
        data: fv.buckets.map(b => b.pct),
        backgroundColor: isAndMode ? AND_STYLE.barBg : getStyleForKeyword(pkFv && pkFv[0] ? pkFv[0].keyword : "Mentions", kwStyles, 0).barBg,
        borderColor: isAndMode ? AND_STYLE.base : getStyleForKeyword(pkFv && pkFv[0] ? pkFv[0].keyword : "Mentions", kwStyles, 0).base,
        borderWidth: 1, borderRadius: 4,
      }];

  fvChart = new Chart(ctx, {
    type: "bar",
    data: { labels, datasets },
    options: {
      responsive: true, maintainAspectRatio: false, animation: { duration: 300 },
      plugins: {
        legend: { display: multiKw || isAndMode, labels: { color: "#8a8a8a", font: { size: 10 }, boxWidth: 14, padding: 8 }, position: "top" },
        tooltip: { callbacks: { label: item => `${item.dataset.label}: P(â‰¥${item.label}) = ${item.raw.toFixed(1)}%` } },
      },
      scales: {
        x: { ticks: { color: "#8a8a8a" }, grid: { display: false } },
        y: { ticks: { color: "#8a8a8a", callback: v => v + "%" }, grid: { display: false }, beginAtZero: true, max: 100 }
      }
    }
  });
}

// â”€â”€ FV grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function saturationBlue(absValue, maxAbsValue) {
  const boundedMax = Math.max(1, Number(maxAbsValue) || 1);
  const ratio = Math.max(0, Math.min(1, Math.abs(Number(absValue) || 0) / boundedMax));
  const sat = Math.round(ratio * 100);
  return `hsl(208, ${sat}%, 72%)`;
}

function renderFVGrid(fv) {
  const maxPct = Math.max(1, ...fv.buckets.map(b => Number(b.pct) || 0));
  document.getElementById("fv-grid").innerHTML = fv.buckets.map(b => {
    const pct = Number(b.pct) || 0;
    const cls = pct >= 30 ? "high" : pct >= 10 ? "medium" : "low";
    const evTone = saturationBlue(pct, maxPct);
    return `<div class="fv-cell">
      <div class="fv-n">â‰¥ ${b.label} mention${b.n !== 1 ? "s" : ""}</div>
      <div class="fv-pct ${cls}" style="color:${evTone}">${pct.toFixed(1)}%</div>
      <div class="fv-label">P(mentions â‰¥ ${b.label})</div>
    </div>`;
  }).join("");
}

function escRegExp(str) {
  return String(str).replace(/[.*+?^${}()|]/g, "$&");
}

function highlightKeywords(text, kwStyles = {}) {
  const terms = Object.keys(kwStyles).filter(Boolean).sort((a, b) => b.length - a.length);
  if (!terms.length) return escHtml(text);

  const pattern = new RegExp("\\b(" + terms.map(escRegExp).join("|") + ")\\b", "gi");
  const safe = escHtml(text);
  return safe.replace(pattern, (matched) => {
    const style = getStyleForKeyword(matched, kwStyles);
    return `<span class="kw-highlight" style="background:${style.hitBg};color:${style.line};box-shadow:0 0 10px ${style.glow};">${matched}</span>`;
  });
}

function renderContextMatch(matchText, kwStyles = {}, keyword = "") {
  const style = getStyleForKeyword(keyword || matchText, kwStyles);
  return `<span class="ctx-match" style="background:${style.hitBg};color:${style.line};box-shadow:0 0 10px ${style.glow};">${escHtml(matchText)}</span>`;
}

// â”€â”€ Episode table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTable(episodes, kwStyles = {}) {
  const tbody = document.getElementById("ep-tbody");
  const pk = (currentData && currentData.per_keyword) || [];
  const perKeywordEpisodeMaps = pk.map(kw => ({
    keyword: kw.keyword,
    idxMap: Object.fromEntries((kw.episodes || []).map(e => [e.episode_id, Number(e.count) || 0])),
  }));

  tbody.innerHTML = episodes.map(ep => {
    const num   = ep.episode_number ? `#${ep.episode_number}` : `ID${ep.episode_id}`;
    const badgeStyle = getStyleForKeyword(currentKeyword || "Mentions", kwStyles, 0);
    const badge = ep.count > 0
      ? `<span class="count-badge dynamic" style="background:${badgeStyle.barBg};border-color:${badgeStyle.base};color:${badgeStyle.line};box-shadow:0 0 10px ${badgeStyle.glow};">${ep.count}</span>`
      : `<span class="count-badge zero">0</span>`;
    const pm    = ep.per_minute > 0 ? `<span class="per-min">${ep.per_minute.toFixed(3)}/min</span>` : "";
    const title = (ep.title || "").slice(0, 55) + ((ep.title || "").length > 55 ? "â€¦" : "");
    return `<tr data-eid="${ep.episode_id}">
      <td class="ep-num">${num}</td>
      <td>${ep.episode_date || "â€”"}</td>
      <td>${badge}</td>
      <td>${pm}</td>
      <td class="ep-title">${highlightKeywords(title, kwStyles)}</td>
    </tr>`;
  }).join("");

  tbody.querySelectorAll("tr").forEach(row => {
    row.addEventListener("click", () => {
      tbody.querySelectorAll("tr").forEach(r => r.classList.remove("selected"));
      row.classList.add("selected");
      loadMinutes(parseInt(row.dataset.eid));
    });
  });
}

// â”€â”€ Per-minute breakdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadMinutes(episodeId) {
  if (!currentKeyword) return;
  loadContext(episodeId, currentKeywordStyles);
  try {
    const mode = (currentData && currentData.mode) || "or";
    const r = await fetch(`/api/minutes?keyword=${encodeURIComponent(currentKeyword)}&episode_id=${episodeId}&mode=${mode}`);
    const d = await r.json();

    const panel = document.getElementById("minute-panel");
    panel.classList.add("visible");
    document.getElementById("minute-title").textContent =
      `Per-minute â€” ${(d.title || String(episodeId)).slice(0, 60)}`;

    const ctx = document.getElementById("minute-chart").getContext("2d");
    if (minuteChart) minuteChart.destroy();

    if (!d.minutes || d.minutes.length === 0) {
      panel.querySelector("canvas").style.display = "none";
      document.getElementById("minute-title").textContent += "  (no mentions)";
      return;
    }
    panel.querySelector("canvas").style.display = "";

    const labels  = d.minutes.map(m => `${m.minute}m`);
    const counts  = d.minutes.map(m => m.count);
    const mean    = counts.reduce((a, b) => a + b, 0) / counts.length;
    const pk      = d.per_keyword;
    const isAndMode = currentData && currentData.mode === "and";
    const isMultiKeyword = pk && pk.length > 1;
    // AND mode can stack cleanly.
    const stacked = !!(isMultiKeyword && isAndMode);

    let barDatasets;
    if (isMultiKeyword) {
      barDatasets = pk.map((kw, i) => {
        const style = getStyleForKeyword(kw.keyword, currentKeywordStyles, i);
        const data = d.minutes.map(m => kw.minutes[m.minute] ?? 0);
        return {
          label: kw.keyword,
          data,
          backgroundColor: style.barBg,
          borderColor: style.base,
          borderWidth: 1,
          borderRadius: 3,
          order: 2,
          stack: stacked ? "kw" : undefined,
        };
      });
    } else {
      const label = pk && pk.length === 1 ? pk[0].keyword : "Mentions";
      const style = getStyleForKeyword(label, currentKeywordStyles, 0);
      barDatasets = [{ label, data: counts, backgroundColor: style.barBg, borderColor: style.base,
                       borderWidth: 1, borderRadius: 3, order: 2 }];
    }

    const rollingWindow = 20;
    const rolling20 = counts.map((_, i) => {
      const start = Math.max(0, i - rollingWindow + 1);
      const window = counts.slice(start, i + 1);
      return window.reduce((sum, value) => sum + value, 0) / window.length;
    });

    const lineDatasets = [
      {
        label: "20m rolling avg",
        data: rolling20,
        type: "line",
        borderColor: "#b7f9ff",
        backgroundColor: "#b7f9ff",
        borderWidth: 2,
        pointRadius: 0,
        tension: 0.25,
        order: 1,
      },
      { label: `Avg ${mean.toFixed(2)}/min`, data: Array(counts.length).fill(mean),
        type: "line", borderColor: "#d9fff6", borderWidth: 1.5, borderDash: [4,4], pointRadius: 0, order: 1 }
    ];

    minuteChart = new Chart(ctx, {
      type: "bar",
      data: { labels, datasets: [
        ...barDatasets,
        ...lineDatasets,
      ]},
      options: {
        responsive: true, maintainAspectRatio: false, animation: { duration: 200 },
        plugins: { legend: { labels: { color: "#8a8a8a", font: { size: 10 }, boxWidth: 14 } } },
        scales: {
          x: { ticks: { color: "#8a8a8a", font: { size: 10 }, maxTicksLimit: 30 }, grid: { display: false }, stacked },
          y: { ticks: { color: "#8a8a8a" }, grid: { display: false }, beginAtZero: true, stacked }
        }
      }
    });

    panel.scrollIntoView({ behavior: "smooth", block: "start" });
  } catch (e) {
    toast("Could not load per-minute data", "error");
  }
}

// â”€â”€ Transcript context (KWIC) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadContext(episodeId, kwStyles = {}) {
  const panel = document.getElementById("context-panel");
  const hitsEl = document.getElementById("context-hits");
  const titleEl = document.getElementById("context-title");
  panel.classList.remove("visible");
  hitsEl.innerHTML = "";
  try {
    const r = await fetch(`/api/context?keyword=${encodeURIComponent(currentKeyword)}&episode_id=${episodeId}`);
    const d = await r.json();
    if (!d.hits || d.hits.length === 0) return;

    titleEl.textContent = `Transcript mentions (${d.hits.length})`;
    hitsEl.innerHTML = d.hits.map(h => {
      const mm = String(h.minute).padStart(2, "0");
      const ss = String(h.second).padStart(2, "0");
      return `<div class="ctx-hit">
        <span class="ctx-ts">${mm}:${ss}</span>
        <span class="ctx-text">${escHtml(h.prefix)}${renderContextMatch(h.match, kwStyles, h.keyword)}${escHtml(h.suffix)}</span>
      </div>`;
    }).join("");
    panel.classList.add("visible");
  } catch (e) {
    // silently skip if context unavailable
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fmt(v) {
  if (v === null || v === undefined) return "â€”";
  return Number(v).toFixed(2);
}

function updateThreshold() {
  const input = document.getElementById("threshold-input");
  const result = document.getElementById("threshold-result");
  const n = parseInt(input.value, 10);
  if (!currentData || isNaN(n) || n < 1) { result.innerHTML = "â€”"; return; }

  const eps   = currentData.episodes;
  const total = eps.length;
  if (total === 0) { result.innerHTML = "â€”"; return; }

  // Use the merged episode count directly â€” this is the same value shown in the table.
  // OR mode:  e.count = total combined mentions (adjacency-deduped across all keywords).
  // AND mode: e.count = total combined mentions in co-occurring episodes; 0 for others,
  //           so episodes where any keyword was absent are naturally excluded.
  const count = eps.filter(e => e.count >= n).length;

  const pct   = (count / total * 100).toFixed(1);
  const color = parseFloat(pct) >= 30 ? "var(--accent)" : parseFloat(pct) >= 10 ? "var(--gold)" : "var(--muted)";
  result.innerHTML =
    `<span style="color:${color}">${count} / ${total}</span>` +
    `<span class="t-frac">(${pct}%)</span>`;
}
document.getElementById("threshold-input").addEventListener("input", updateThreshold);

function escHtml(str) {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

function toast(msg, type) {
  const el = document.getElementById("toast");
  el.textContent = msg;
  el.className = `toast${type ? " " + type : ""}`;
  el.classList.add("show");
  clearTimeout(el._t);
  el._t = setTimeout(() => el.classList.remove("show"), 3200);
}
</script>
</body>
</html>
